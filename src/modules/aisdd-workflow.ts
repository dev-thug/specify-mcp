/**
 * AI-SDD Workflow Implementation
 * Orchestrates the complete AI-Augmented Specification-Driven Development process
 */

import { CommonValidationModule, ValidationInput } from '../validation/common-validation.js';
import type {
  UserIntent,
  ResolvedIntent,
  AmbiguityResolution,
  Specification,
  ImplementationPlan,
  SystemArchitecture,
  DevelopmentPhase,
  Timeline,
  ResourceRequirement,
  RiskAssessment,
  DependencyGraph,
  Task,
  AcceptanceCriteria,
  ValidationResult,
  Requirement
} from '../types/index.js';

/**
 * Configuration interface for AISDD Workflow
 */
interface AISDDConfig {
  validation?: {
    multiRunCount?: number;
    consensusThreshold?: number;
    maxIterations?: number;
    enableCritics?: boolean;
  };
  llm?: {
    model?: string;
    temperature?: number;
    maxTokens?: number;
    timeout?: number;
  };
  critics?: {
    enabled?: boolean;
    tools?: string[];
    thresholds?: {
      correctness?: number;
      security?: number;
      maintainability?: number;
    };
  };
  quality?: {
    minCompleteness?: number;
    minClarity?: number;
    minCorrectness?: number;
    minConsistency?: number;
  };
}


/**
 * Helper class for building structured specifications
 */
class SpecificationBuilder {
  private sections: { title: string; content: string[] }[] = [];
  private intent: ResolvedIntent;
  private level: string;

  constructor(intent: ResolvedIntent, level: string) {
    this.intent = intent;
    this.level = level;
  }

  addSection(title: string, content: string[]): void {
    this.sections.push({ title, content });
  }

  build(): string {
    const header = `# System Specification\n\nGenerated: ${new Date().toISOString()}\nConfidence: ${(this.intent.confidence * 100).toFixed(1)}%\n`;
    
    const sections = this.sections.map(section => 
      `\n## ${section.title}\n\n${section.content.join('\n')}`
    ).join('\n');

    const footer = this.level === 'comprehensive' ? 
      '\n\n## Specification Metadata\n\n' +
      `- Specification Level: ${this.level}\n` +
      `- Ambiguities Resolved: ${this.intent.ambiguities?.length || 0}\n` +
      `- Confidence Score: ${(this.intent.confidence * 100).toFixed(1)}%\n` +
      `- Generated By: AI-SDD Framework v1.0\n` : '';

    return header + sections + footer;
  }
}

/**
 * ACSL Builder for structured formal specification generation
 */
class ACSLBuilder {
  private intent: ResolvedIntent;
  private contracts: string[] = [];
  private predicates: string[] = [];
  private axioms: string[] = [];
  private functions: string[] = [];

  constructor(intent: ResolvedIntent) {
    this.intent = intent;
  }

  addGlobalContracts(): void {
    this.contracts.push('// === GLOBAL CONTRACTS ===');
    this.contracts.push('');
    
    // System-level invariants
    this.contracts.push('/*@ global invariant system_integrity:');
    this.contracts.push('    \\forall \\integer t; t >= 0 ==> system_state_valid(t);');
    this.contracts.push('*/');
    this.contracts.push('');
    
    // Domain-specific global contracts
    const domain = this.intent.domain || 'general';
    this.addDomainGlobalContracts(domain);
  }

  addDomainGlobalContracts(domain: string): void {
    const domainContracts: Record<string, string[]> = {
      web: [
        '/*@ global invariant web_security:',
        '    \\forall user u; authenticated(u) ==> authorized(u, u.permissions);',
        '*/'
      ],
      api: [
        '/*@ global invariant api_consistency:',
        '    \\forall request r; valid_request(r) ==> response_matches_schema(process(r));',
        '*/'
      ],
      mobile: [
        '/*@ global invariant mobile_sync:',
        '    \\forall data d; offline_modified(d) ==> eventually_synced(d);',
        '*/'
      ]
    };

    const contracts = domainContracts[domain];
    if (contracts) {
      this.contracts.push(...contracts);
      this.contracts.push('');
    }
  }

  addFunctionContracts(naturalSpec: string): void {
    this.contracts.push('// === FUNCTION CONTRACTS ===');
    this.contracts.push('');
    
    // Extract key operations from natural language spec
    const operations = this.extractOperations(naturalSpec);
    
    operations.forEach(op => {
      this.addOperationContract(op);
    });
  }

  extractOperations(spec: string): Array<{name: string, type: string, description: string}> {
    const operations: Array<{name: string, type: string, description: string}> = [];
    
    // Pattern matching for common operations
    const operationPatterns = [
      { pattern: /create|add|insert|register/, name: 'create_entity', type: 'create' },
      { pattern: /update|modify|edit|change/, name: 'update_entity', type: 'update' },
      { pattern: /delete|remove|destroy/, name: 'delete_entity', type: 'delete' },
      { pattern: /retrieve|get|fetch|find|search/, name: 'retrieve_entity', type: 'read' },
      { pattern: /authenticate|login|verify/, name: 'authenticate_user', type: 'auth' },
      { pattern: /validate|check|verify/, name: 'validate_data', type: 'validation' },
      { pattern: /process|handle|execute/, name: 'process_request', type: 'process' }
    ];

    const specLower = spec.toLowerCase();
    operationPatterns.forEach(({pattern, name, type}) => {
      if (pattern.test(specLower)) {
        operations.push({
          name,
          type,
          description: `${type} operation as specified in requirements`
        });
      }
    });

    return operations.length > 0 ? operations : [{
      name: 'main_functionality',
      type: 'general',
      description: this.intent.description
    }];
  }

  addOperationContract(op: {name: string, type: string, description: string}): void {
    const contractTemplates: Record<string, string[]> = {
      create: [
        `/*@ requires input_valid(data);`,
        `    requires !entity_exists(data.id);`,
        `    assigns entity_storage;`,
        `    ensures entity_exists(data.id);`,
        `    ensures entity_data_matches(data.id, data);`,
        `*/`
      ],
      read: [
        `/*@ requires entity_exists(id);`,
        `    requires read_permission(current_user, id);`,
        `    assigns \\nothing;`,
        `    ensures \\result == entity_data(id);`,
        `*/`
      ],
      update: [
        `/*@ requires entity_exists(id);`,
        `    requires update_permission(current_user, id);`,
        `    requires input_valid(new_data);`,
        `    assigns entity_storage[id];`,
        `    ensures entity_data(id) == new_data;`,
        `*/`
      ],
      delete: [
        `/*@ requires entity_exists(id);`,
        `    requires delete_permission(current_user, id);`,
        `    assigns entity_storage;`,
        `    ensures !entity_exists(id);`,
        `*/`
      ],
      auth: [
        `/*@ requires credentials_format_valid(credentials);`,
        `    assigns authentication_state;`,
        `    ensures \\result ==> authenticated(user_from_credentials(credentials));`,
        `    ensures !\\result ==> !authenticated(user_from_credentials(credentials));`,
        `*/`
      ],
      validation: [
        `/*@ requires input != NULL;`,
        `    assigns \\nothing;`,
        `    ensures \\result <==> data_meets_constraints(input);`,
        `*/`
      ]
    };

    const template = contractTemplates[op.type] || contractTemplates['validation'];
    
    this.contracts.push(`// Contract for: ${op.description}`);
    if (template && template.length > 0) {
      this.contracts.push(`${template[0]}`);
      template.slice(1).forEach(line => {
        this.contracts.push(`${line}`);
      });
    }
    this.contracts.push(`result_type ${op.name}(input_type data);`);
    this.contracts.push('');
  }

  addDataStructures(): void {
    this.contracts.push('// === DATA STRUCTURE SPECIFICATIONS ===');
    this.contracts.push('');
    
    // Generate predicates for data validity
    this.predicates.push('/*@ predicate input_valid(data_type data) =');
    this.predicates.push('    data != NULL && data_format_correct(data) && data_constraints_met(data);');
    this.predicates.push('*/');
    this.predicates.push('');
    
    this.predicates.push('/*@ predicate system_state_valid(\\integer timestamp) =');
    this.predicates.push('    consistency_maintained(timestamp) && integrity_preserved(timestamp);');
    this.predicates.push('*/');
    this.predicates.push('');
    
    // Domain-specific data structures
    this.addDomainDataStructures();
  }

  addDomainDataStructures(): void {
    const domain = this.intent.domain || 'general';
    
    const domainPredicates: Record<string, string[]> = {
      web: [
        '/*@ predicate web_session_valid(session s) =',
        '    s.user_id > 0 && s.expiry > current_time() && s.csrf_token_valid;',
        '*/'
      ],
      api: [
        '/*@ predicate api_request_valid(request r) =',
        '    r.method in {GET, POST, PUT, DELETE} && r.endpoint_exists && r.auth_valid;',
        '*/'
      ],
      mobile: [
        '/*@ predicate mobile_data_synced(data d) =',
        '    d.local_version == d.server_version && d.conflict_resolved;',
        '*/'
      ]
    };

    const predicates = domainPredicates[domain];
    if (predicates) {
      this.predicates.push(...predicates);
      this.predicates.push('');
    }
  }

  addBehavioralContracts(intent: ResolvedIntent): void {
    this.contracts.push('// === BEHAVIORAL CONTRACTS ===');
    this.contracts.push('');
    
    // Generate contracts based on quality attributes
    const description = intent.description.toLowerCase();
    const clarifications = intent.clarifications.join(' ').toLowerCase();
    const fullText = `${description} ${clarifications}`;
    
    if (/\b(secure|security)\b/.test(fullText)) {
      this.addSecurityContracts();
    }
    
    if (/\b(performance|fast|speed)\b/.test(fullText)) {
      this.addPerformanceContracts();
    }
    
    if (/\b(reliable|robust)\b/.test(fullText)) {
      this.addReliabilityContracts();
    }
  }

  addSecurityContracts(): void {
    this.contracts.push('/*@ behavior security_enforcement:');
    this.contracts.push('    assumes security_enabled;');
    this.contracts.push('    requires user_authenticated && user_authorized;');
    this.contracts.push('    ensures access_logged && audit_trail_updated;');
    this.contracts.push('*/');
    this.contracts.push('');
  }

  addPerformanceContracts(): void {
    this.contracts.push('/*@ behavior performance_guarantee:');
    this.contracts.push('    assumes system_resources_available;');
    this.contracts.push('    ensures response_time <= MAX_RESPONSE_TIME;');
    this.contracts.push('    ensures memory_usage <= MAX_MEMORY_LIMIT;');
    this.contracts.push('*/');
    this.contracts.push('');
  }

  addReliabilityContracts(): void {
    this.contracts.push('/*@ behavior reliability_assurance:');
    this.contracts.push('    ensures error_handled_gracefully;');
    this.contracts.push('    ensures system_state_consistent;');
    this.contracts.push('    ensures recovery_possible_on_failure;');
    this.contracts.push('*/');
    this.contracts.push('');
  }

  addVerificationConditions(): void {
    this.contracts.push('// === VERIFICATION CONDITIONS ===');
    this.contracts.push('');
    
    this.axioms.push('/*@ axiomatic SystemProperties {');
    this.axioms.push('    logic \\boolean system_initialized();');
    this.axioms.push('    logic \\boolean data_consistent();');
    this.axioms.push('    logic \\boolean security_maintained();');
    this.axioms.push('');
    this.axioms.push('    axiom system_startup: system_initialized() ==> data_consistent();');
    this.axioms.push('    axiom security_invariant: \\forall \\integer t;');
    this.axioms.push('        system_running(t) ==> security_maintained();');
    this.axioms.push('  }');
    this.axioms.push('*/');
  }

  build(): string {
    const header = [
      '/*',
      ' * ACSL Specification Generated from Natural Language Requirements',
      ` * Source Intent: ${this.intent.description}`,
      ` * Domain: ${this.intent.domain || 'General'}`,
      ` * Confidence: ${(this.intent.confidence * 100).toFixed(1)}%`,
      ` * Generated: ${new Date().toISOString()}`,
      ' */\n'
    ].join('\n');

    const sections = [
      header,
      this.contracts.join('\n'),
      this.predicates.join('\n'),
      this.axioms.join('\n')
    ].filter(section => section.trim().length > 0);

    return sections.join('\n\n');
  }
}

export interface SpecificationOptions {
  includeFormalSpec?: boolean;
  level?: 'basic' | 'detailed' | 'comprehensive';
}

export interface PlanningOptions {
  planningHorizon?: number;
  teamSize?: number;
  includeDependencyGraph?: boolean;
  riskTolerance?: 'low' | 'medium' | 'high';
}

export interface TaskGenerationOptions {
  granularity?: 'coarse' | 'medium' | 'fine';
  includeTestTasks?: boolean;
  maxTasksPerPhase?: number;
  prioritizeParallelization?: boolean;
}

export interface WorkflowResult {
  readonly resolvedIntent: ResolvedIntent;
  readonly specification: Specification;
  readonly plan: ImplementationPlan;
  readonly tasks: Task[];
  readonly validationHistory: ValidationResult[];
  readonly qualityScore: number;
}

/**
 * Main AISDDWorkflow class - orchestrates the complete AI-SDD process
 */
export class AISDDWorkflow {
  private validationModule: CommonValidationModule;
  private config: AISDDConfig;

  constructor(config: AISDDConfig = {}) {
    this.config = config;
    this.validationModule = new CommonValidationModule({
      multiRunCount: 3,
      consensusThreshold: 0.8,
      maxIterations: 5,
      enableCritics: true
    }, {
      enabled: true,
      tools: ['consistency_check', 'completeness_check'],
      thresholds: { minScore: 0.7, maxErrors: 5 }
    });
  }

  /**
   * Step 0: Autonomous Ambiguity Resolution
   * Resolves ambiguous requirements using NLP and RAG
   */
  async resolveAmbiguities(userIntent: UserIntent): Promise<ResolvedIntent> {
    const validationInput: ValidationInput = {
      content: userIntent,
      phase: 'ambiguity-resolution'
    };

    // Simulate ambiguity detection and resolution
    const ambiguities = this.detectAmbiguities(userIntent.description);
    const resolutions = await this.resolveDetectedAmbiguities(ambiguities, userIntent);
    const clarifications = this.generateClarifications(userIntent, resolutions);

    const resolvedIntent: ResolvedIntent = {
      ...userIntent,
      ambiguities: resolutions,
      clarifications,
      confidence: this.calculateIntentConfidence(resolutions)
    };

    // Validate the resolution
    const validationResult = await this.validationModule.validate({
      ...validationInput,
      content: resolvedIntent
    });

    if (!validationResult.isValid) {
      throw new Error(`Ambiguity resolution validation failed: ${validationResult.errors.map(e => e.message).join(', ')}`);
    }

    return resolvedIntent;
  }

  /**
   * Step 1: Specification Generation with NL-ACSL Translation
   */
  async generateSpecification(
    intent: ResolvedIntent,
    options: SpecificationOptions = {}
  ): Promise<Specification> {
    const { includeFormalSpec = true, level = 'detailed' } = options;

    // Generate natural language specification
    const naturalLanguage = this.generateNaturalLanguageSpec(intent, level);
    
    // Generate formal specification (ACSL) if requested
    const formalSpec = includeFormalSpec 
      ? this.translateToACSL(naturalLanguage, intent)
      : undefined;

    const nlSpec = naturalLanguage;
    const acslSpec = formalSpec;

    // Extract requirements from specification
    const requirements = this.extractRequirements(naturalLanguage, intent);
    
    // Identify constraints
    const constraints = intent.constraints?.map(c => ({
      id: `constraint-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      type: 'business' as const,
      description: c,
      priority: 'medium' as const,
      impact: 'medium' as const,
      source: 'user-input'
    })) || [];

    // Make architecture decisions
    const architecture = this.makeArchitectureDecisions(intent, requirements);

    const specification: Specification = {
      naturalLanguage: nlSpec,
      ...(options.includeFormalSpec && { formalSpec: acslSpec }),
      requirements,
      constraints,
      architecture,
      metadata: {
        version: '1.0.0',
        createdAt: new Date(),
        updatedAt: new Date(),
        author: 'AI-SDD System',
        reviewStatus: 'draft'
      }
    };

    // Validate specification
    const validationResult = await this.validationModule.validate({
      content: specification,
      previousContent: intent,
      phase: 'specification-generation'
    });

    if (!validationResult.isValid) {
      throw new Error(`Specification validation failed: ${validationResult.errors.map(e => e.message).join(', ')}`);
    }

    return specification;
  }

  /**
   * Step 2: Planning with Risk Assessment and Dependency Optimization
   */
  async createImplementationPlan(
    specification: Specification,
    options: PlanningOptions = {}
  ): Promise<ImplementationPlan> {
    const {
      planningHorizon = 30,
      teamSize = 3,
      includeDependencyGraph = true,
      riskTolerance = 'medium'
    } = options;

    // Design system architecture
    const architecture = this.designSystemArchitecture(specification);
    
    // Plan development phases
    const phases = this.planDevelopmentPhases(specification, architecture, teamSize);
    
    // Create timeline
    const timeline = this.createTimeline(phases, planningHorizon);
    
    // Identify resource requirements
    const resources = this.identifyResourceRequirements(phases, teamSize, architecture);
    
    // Assess risks
    const risks = this.assessRisks(specification, architecture, phases, riskTolerance);
    
    // Build dependency graph
    const dependencies = includeDependencyGraph 
      ? this.buildDependencyGraph(phases, risks)
      : { nodes: [], edges: [], criticalPath: [] };

    const plan: ImplementationPlan = {
      architecture,
      phases,
      timeline,
      resources,
      risks,
      dependencies
    };

    // Validate plan
    const validationResult = await this.validationModule.validate({
      content: plan,
      previousContent: specification,
      phase: 'planning'
    });

    if (!validationResult.isValid) {
      throw new Error(`Planning validation failed: ${validationResult.errors.map(e => e.message).join(', ')}`);
    }

    return plan;
  }

  /**
   * Step 3: Task Generation with SMART Criteria and Quality Enhancement
   */
  async generateTasks(
    plan: ImplementationPlan,
    options: TaskGenerationOptions = {}
  ): Promise<Task[]> {
    const {
      granularity = 'medium',
      includeTestTasks = true,
      maxTasksPerPhase = 10,
      prioritizeParallelization = true
    } = options;

    let allTasks: Task[] = [];

    // Generate tasks for each development phase
    for (const phase of plan.phases) {
      const phaseTasks = this.generatePhaseTasksSMART(
        phase,
        plan.architecture,
        granularity,
        maxTasksPerPhase
      );
      allTasks.push(...phaseTasks);

      // Add test tasks if requested
      if (includeTestTasks) {
        const testTasks = this.generateTestTasks(phase, phaseTasks);
        allTasks.push(...testTasks);
      }
    }

    // Apply task quality enhancement
    allTasks = this.enhanceTaskQuality(allTasks, prioritizeParallelization);

    // Validate tasks
    const validationResult = await this.validationModule.validate({
      content: allTasks,
      previousContent: plan,
      phase: 'tasking'
    });

    if (!validationResult.isValid) {
      throw new Error(`Task generation validation failed: ${validationResult.errors.map(e => e.message).join(', ')}`);
    }

    return allTasks;
  }

  /**
   * Run complete AI-SDD workflow
   */
  async runFullWorkflow(
    userIntent: UserIntent,
    options: Partial<SpecificationOptions & PlanningOptions & TaskGenerationOptions> = {}
  ): Promise<WorkflowResult> {
    const validationHistory: ValidationResult[] = [];

    try {
      // Step 0: Resolve ambiguities
      const resolvedIntent = await this.resolveAmbiguities(userIntent);

      // Step 1: Generate specification
      const specification = await this.generateSpecification(resolvedIntent, {
        ...(options.includeFormalSpec !== undefined && { includeFormalSpec: options.includeFormalSpec }),
        ...(options.level !== undefined && { level: options.level })
      });

      // Step 2: Create implementation plan
      const plan = await this.createImplementationPlan(specification, {
        ...(options.planningHorizon !== undefined && { planningHorizon: options.planningHorizon }),
        ...(options.teamSize !== undefined && { teamSize: options.teamSize }),
        ...(options.includeDependencyGraph !== undefined && { includeDependencyGraph: options.includeDependencyGraph }),
        ...(options.riskTolerance !== undefined && { riskTolerance: options.riskTolerance })
      });

      // Step 3: Generate tasks
      const tasks = await this.generateTasks(plan, {
        ...(options.granularity !== undefined && { granularity: options.granularity }),
        ...(options.includeTestTasks !== undefined && { includeTestTasks: options.includeTestTasks }),
        ...(options.maxTasksPerPhase !== undefined && { maxTasksPerPhase: options.maxTasksPerPhase }),
        ...(options.prioritizeParallelization !== undefined && { prioritizeParallelization: options.prioritizeParallelization })
      });

      // Calculate overall quality score
      const qualityScore = this.calculateOverallQuality(
        resolvedIntent,
        specification,
        plan,
        tasks,
        validationHistory
      );

      return {
        resolvedIntent,
        specification,
        plan,
        tasks,
        validationHistory,
        qualityScore
      };

    } catch (error) {
      throw new Error(`Workflow execution failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  // Private helper methods

  /**
   * Enhanced NLP-based ambiguity detection
   * Detects multiple types of ambiguities using linguistic patterns and semantic analysis
   */
  private detectAmbiguities(description: string): string[] {
    const ambiguities: string[] = [];

    // 1. Lexical ambiguities - vague qualifiers and subjective terms
    const lexicalPatterns = [
      /\b(maybe|perhaps|might|could|should|would|probably|likely)\b/gi,
      /\b(some|several|many|few|various|multiple|numerous)\b/gi,
      /\b(fast|slow|big|small|good|bad|nice|easy|hard|simple|complex)\b/gi,
      /\b(user-friendly|responsive|secure|scalable|efficient|robust|flexible)\b/gi,
      /\b(as needed|if possible|when appropriate|where applicable|if required)\b/gi,
      /\b(high|low|better|worse|optimal|adequate|sufficient|appropriate)\b/gi
    ];

    // 2. Syntactic ambiguities - ambiguous sentence structures
    const syntacticPatterns = [
      /\b(and\/or|or)\b/gi, // Disjunctive ambiguity
      /\b(they|it|this|that|these|those)\b(?!\s+(?:will|should|must|can))/gi, // Pronoun reference
      /\b(automatically|dynamically|intelligently)\b/gi // Process ambiguity
    ];

    // 3. Semantic ambiguities - context-dependent meanings
    const semanticPatterns = [
      /\b(system|platform|application|solution|tool|interface)\b/gi, // Scope ambiguity
      /\b(users?|clients?|customers?|stakeholders?)\b/gi, // Actor ambiguity
      /\b(data|information|content|resources?)\b/gi, // Object ambiguity
      /\b(integrate|connect|link|sync|communicate)\b/gi // Relationship ambiguity
    ];

    // 4. Temporal ambiguities
    const temporalPatterns = [
      /\b(soon|later|eventually|immediately|quickly|slowly)\b/gi,
      /\b(before|after|during|while|when)\b/gi,
      /\b(real-time|batch|periodic|continuous)\b/gi
    ];

    // 5. Quantitative ambiguities
    const quantitativePatterns = [
      /\b(all|most|some|few|many|several|multiple)\s+\w+/gi,
      /\b(up to|at least|approximately|around|about)\s+\d+/gi,
      /\b(large|small|medium|significant|minor)\s+(amount|number|quantity)/gi
    ];

    const allPatterns = [
      ...lexicalPatterns,
      ...syntacticPatterns, 
      ...semanticPatterns,
      ...temporalPatterns,
      ...quantitativePatterns
    ];

    // Extract ambiguous terms with context
    for (const pattern of allPatterns) {
      const matches = description.match(pattern);
      if (matches) {
        ambiguities.push(...matches.map(match => match.trim().toLowerCase()));
      }
    }

    // 6. Detect incomplete specifications using sentence analysis
    const sentences = description.split(/[.!?]+/).filter(s => s.trim().length > 0);
    for (const sentence of sentences) {
      // Check for incomplete specifications
      if (sentence.length < 20 && !/\b(will|must|should|shall)\b/i.test(sentence)) {
        ambiguities.push(`incomplete_specification: ${sentence.trim()}`);
      }
      
      // Check for missing subjects or objects
      if (/^\s*(and|or|but|also)\b/i.test(sentence)) {
        ambiguities.push(`missing_context: ${sentence.trim()}`);
      }
    }

    return [...new Set(ambiguities)]; // Remove duplicates
  }

  /**
   * Enhanced RAG-based ambiguity resolution
   * Uses retrieval-augmented generation with domain knowledge and best practices
   */
  private async resolveDetectedAmbiguities(
    ambiguities: string[],
    intent: UserIntent
  ): Promise<AmbiguityResolution[]> {
    const resolutions: AmbiguityResolution[] = [];

    for (const ambiguity of ambiguities) {
      // 1. Retrieve relevant context from domain knowledge
      const domainContext = this.retrieveDomainKnowledge(ambiguity, intent.domain);
      
      // 2. Apply resolution strategies based on ambiguity type
      const resolutionStrategy = this.determineResolutionStrategy(ambiguity);
      
      // 3. Generate specific resolution using RAG
      const resolved = await this.generateContextualResolution(
        ambiguity, 
        intent, 
        domainContext, 
        resolutionStrategy
      );
      
      // 4. Calculate confidence based on multiple factors
      const confidence = this.calculateResolutionConfidence(
        ambiguity, 
        resolved, 
        domainContext,
        intent
      );
      
      // 5. Generate detailed reasoning
      const reasoning = this.generateResolutionReasoning(
        ambiguity,
        resolved,
        resolutionStrategy,
        domainContext
      );

      resolutions.push({
        original: ambiguity,
        resolved,
        confidence,
        reasoning
      });
    }

    return resolutions;
  }

  /**
   * Retrieve domain-specific knowledge for ambiguity resolution
   */
  private retrieveDomainKnowledge(ambiguity: string, domain?: string): any {
    const knowledgeBase = {
      web: {
        'user-friendly': {
          patterns: ['responsive design', 'accessibility standards', 'intuitive navigation'],
          metrics: ['usability score > 80', 'task completion rate > 95%'],
          standards: ['WCAG 2.1 AA', 'Material Design', 'HIG']
        },
        'responsive': {
          patterns: ['mobile-first design', 'progressive enhancement'],
          metrics: ['< 200ms interaction response', '< 3s page load'],
          standards: ['Core Web Vitals', 'PWA criteria']
        },
        'secure': {
          patterns: ['HTTPS', 'CSP headers', 'input sanitization'],
          metrics: ['OWASP compliance', 'zero XSS vulnerabilities'],
          standards: ['OWASP Top 10', 'CSP Level 3']
        }
      },
      mobile: {
        'responsive': {
          patterns: ['adaptive UI', 'offline capability'],
          metrics: ['< 100ms touch response', 'battery efficiency'],
          standards: ['Material Design', 'HIG']
        }
      },
      api: {
        'scalable': {
          patterns: ['horizontal scaling', 'caching layers', 'load balancing'],
          metrics: ['10x traffic capacity', '< 1% error rate'],
          standards: ['REST Level 3', 'OpenAPI 3.0']
        },
        'secure': {
          patterns: ['OAuth 2.0', 'rate limiting', 'API key management'],
          metrics: ['zero unauthorized access', 'audit logging'],
          standards: ['OAuth 2.1', 'JWT best practices']
        }
      }
    };

    const domainKnowledge = knowledgeBase[domain as keyof typeof knowledgeBase] || {};
    const ambiguityKey = ambiguity.toLowerCase().replace(/\b(and|or|the|a|an)\b/g, '').trim();
    
    // Find best matching knowledge entry
    for (const [key, knowledge] of Object.entries(domainKnowledge)) {
      if (ambiguityKey.includes(key) || key.includes(ambiguityKey)) {
        return { key, ...knowledge, domain };
      }
    }

    return { patterns: [], metrics: [], standards: [], domain };
  }

  /**
   * Determine resolution strategy based on ambiguity type
   */
  private determineResolutionStrategy(ambiguity: string): string {
    if (ambiguity.startsWith('incomplete_specification:')) return 'completion';
    if (ambiguity.startsWith('missing_context:')) return 'contextualization';
    if (/\b(fast|slow|good|bad)\b/i.test(ambiguity)) return 'quantification';
    if (/\b(user-friendly|responsive|secure)\b/i.test(ambiguity)) return 'specification';
    if (/\b(some|many|few)\b/i.test(ambiguity)) return 'enumeration';
    if (/\b(system|platform|application)\b/i.test(ambiguity)) return 'scoping';
    return 'clarification';
  }

  /**
   * Generate contextual resolution using domain knowledge
   */
  private async generateContextualResolution(
    ambiguity: string,
    intent: UserIntent,
    domainContext: any,
    strategy: string
  ): Promise<string> {
    const baseAmbiguity = ambiguity.toLowerCase();

    switch (strategy) {
      case 'specification':
        if (domainContext.patterns?.length > 0) {
          return `${baseAmbiguity} means: ${domainContext.patterns.join(', ')}, ` +
                 `measured by: ${domainContext.metrics?.join(', ') || 'standard metrics'}, ` +
                 `following: ${domainContext.standards?.join(', ') || 'industry standards'}`;
        }
        break;
        
      case 'quantification': {
        const quantificationMap: Record<string, string> = {
          'fast': 'response time < 500ms for 95th percentile, throughput > 1000 req/s',
          'slow': 'acceptable response time up to 2s for complex operations',
          'big': 'handles datasets > 1TB, supports > 100k concurrent users',
          'small': 'lightweight footprint < 50MB RAM, minimal dependencies',
          'good': 'exceeds industry benchmarks by 20%, user satisfaction > 85%',
          'high': 'performance in top 10th percentile of comparable solutions'
        };
        return quantificationMap[baseAmbiguity] || `specific measurable criteria for ${baseAmbiguity}`;
      }
        
      case 'enumeration': {
        const enumerationMap: Record<string, string> = {
          'some': 'at least 3 but no more than 10',
          'many': 'more than 10, typically 15-50',
          'few': '2-5 items',
          'several': '3-7 items',
          'multiple': 'at least 2, specific number to be determined by requirements'
        };
        return enumerationMap[baseAmbiguity] || `specific count or range for ${baseAmbiguity}`;
      }
        
      case 'scoping': {
        const scopingMap: Record<string, string> = {
          'system': 'complete software solution including backend, frontend, and data layer',
          'platform': 'foundational infrastructure supporting multiple applications',
          'application': 'end-user focused software with specific business functionality',
          'solution': 'comprehensive approach addressing the stated business problem',
          'tool': 'utility software designed for specific tasks or workflows'
        };
        return scopingMap[baseAmbiguity] || `clearly defined scope for ${baseAmbiguity}`;
      }
        
      case 'completion': {
        const incomplete = ambiguity.replace('incomplete_specification:', '').trim();
        return `${incomplete} - requires additional details about scope, constraints, and success criteria`;
      }
        
      case 'contextualization': {
        const missing = ambiguity.replace('missing_context:', '').trim();
        return `${missing} - needs clear subject and object references to previous requirements`;
      }
        
      default:
        return `specific, measurable definition for "${baseAmbiguity}" in the context of ${intent.domain || 'this application'}`;
    }

    return `specific, measurable definition for "${baseAmbiguity}"`;
  }

  /**
   * Calculate confidence based on multiple factors
   */
  private calculateResolutionConfidence(
    ambiguity: string,
    resolved: string,
    domainContext: any,
    intent: UserIntent
  ): number {
    let confidence = 0.5; // Base confidence

    // Domain knowledge availability
    if (domainContext.patterns?.length > 0) confidence += 0.2;
    if (domainContext.metrics?.length > 0) confidence += 0.15;
    if (domainContext.standards?.length > 0) confidence += 0.1;

    // Resolution specificity
    if (resolved.includes('measured by') || resolved.includes('following')) confidence += 0.15;
    if (/\d+/.test(resolved)) confidence += 0.1; // Contains numbers/metrics
    if (resolved.length > 50) confidence += 0.1; // Detailed resolution

    // Context alignment
    if (intent.domain && domainContext.domain === intent.domain) confidence += 0.1;
    if (intent.constraints?.some(c => resolved.toLowerCase().includes(c.toLowerCase()))) confidence += 0.05;

    return Math.min(confidence, 1.0);
  }

  /**
   * Generate detailed reasoning for the resolution
   */
  private generateResolutionReasoning(
    ambiguity: string,
    resolved: string,
    strategy: string,
    domainContext: any
  ): string {
    const reasoningParts = [];

    reasoningParts.push(`Applied ${strategy} strategy`);
    
    if (domainContext.domain) {
      reasoningParts.push(`using ${domainContext.domain} domain knowledge`);
    }
    
    if (domainContext.standards?.length > 0) {
      reasoningParts.push(`following ${domainContext.standards.join(', ')} standards`);
    }
    
    reasoningParts.push(`to transform vague requirement into specific, measurable criteria`);

    return reasoningParts.join(' ');
  }

  /**
   * Generate comprehensive clarifications with justification
   */
  private generateClarifications(intent: UserIntent, resolutions: AmbiguityResolution[]): string[] {
    const clarifications: string[] = [];

    // Group resolutions by type for better organization
    const groupedResolutions = this.groupResolutionsByType(resolutions);
    
    for (const [type, typeResolutions] of Object.entries(groupedResolutions)) {
      if (typeResolutions.length === 1) {
        const r = typeResolutions[0];
        if (r) {
          clarifications.push(
            `[${type.toUpperCase()}] "${r.original}" → "${r.resolved}" ` +
            `(confidence: ${(r.confidence * 100).toFixed(0)}%, ${r.reasoning})`
          );
        }
      } else {
        clarifications.push(`[${type.toUpperCase()}] Resolved ${typeResolutions.length} ${type} ambiguities:`);
        typeResolutions.forEach((r, i) => {
          clarifications.push(
            `  ${i + 1}. "${r.original}" → "${r.resolved.substring(0, 80)}${r.resolved.length > 80 ? '...' : ''}" ` +
            `(${(r.confidence * 100).toFixed(0)}%)`
          );
        });
      }
    }

    // Add summary statistics
    const avgConfidence = resolutions.reduce((sum, r) => sum + r.confidence, 0) / resolutions.length;
    const highConfidenceCount = resolutions.filter(r => r.confidence > 0.8).length;
    
    clarifications.push(
      `\nResolution Summary: ${resolutions.length} ambiguities resolved, ` +
      `average confidence ${(avgConfidence * 100).toFixed(0)}%, ` +
      `${highConfidenceCount} high-confidence resolutions`
    );

    return clarifications;
  }

  /**
   * Group resolutions by ambiguity type for better organization
   */
  private groupResolutionsByType(resolutions: AmbiguityResolution[]): Record<string, AmbiguityResolution[]> {
    const groups: Record<string, AmbiguityResolution[]> = {
      lexical: [],
      syntactic: [],
      semantic: [],
      temporal: [],
      quantitative: [],
      structural: []
    };

    for (const resolution of resolutions) {
      const ambiguity = resolution.original.toLowerCase();
      
      if (/\b(fast|slow|good|bad|user-friendly|responsive)\b/.test(ambiguity)) {
        groups.lexical?.push(resolution);
      } else if (/\b(and\/or|they|it|this)\b/.test(ambiguity)) {
        groups.syntactic?.push(resolution);
      } else if (/\b(system|platform|users?|data)\b/.test(ambiguity)) {
        groups.semantic?.push(resolution);
      } else if (/\b(soon|later|real-time|before)\b/.test(ambiguity)) {
        groups.temporal?.push(resolution);
      } else if (/\b(some|many|few|all|most)\b/.test(ambiguity)) {
        groups.quantitative?.push(resolution);
      } else if (ambiguity.startsWith('incomplete_') || ambiguity.startsWith('missing_')) {
        groups.structural?.push(resolution);
      } else {
        groups.lexical?.push(resolution); // Default to lexical
      }
    }

    // Remove empty groups
    return Object.fromEntries(
      Object.entries(groups).filter(([_, resolutions]) => resolutions.length > 0)
    );
  }

  /**
   * Calculate overall intent confidence using weighted factors
   */
  private calculateIntentConfidence(resolutions: AmbiguityResolution[]): number {
    if (resolutions.length === 0) return 1.0;

    // Base confidence from resolution average
    const avgResolutionConfidence = resolutions.reduce((sum, r) => sum + r.confidence, 0) / resolutions.length;
    
    // Penalty for high number of ambiguities (indicates unclear requirements)
    const ambiguityPenalty = Math.max(0, (resolutions.length - 5) * 0.02);
    
    // Bonus for high-confidence resolutions
    const highConfidenceBonus = resolutions.filter(r => r.confidence > 0.9).length * 0.01;
    
    // Penalty for low-confidence resolutions
    const lowConfidencePenalty = resolutions.filter(r => r.confidence < 0.6).length * 0.05;
    
    // Bonus for structural completeness (few incomplete/missing context issues)
    const structuralBonus = resolutions.filter(r => 
      !r.original.startsWith('incomplete_') && !r.original.startsWith('missing_')
    ).length / resolutions.length * 0.1;

    const finalConfidence = avgResolutionConfidence 
      - ambiguityPenalty 
      + highConfidenceBonus 
      - lowConfidencePenalty 
      + structuralBonus;

    return Math.max(0.1, Math.min(1.0, finalConfidence));
  }

  /**
   * Enhanced Natural Language Specification Generation
   * Generates comprehensive specifications with domain-specific patterns
   */
  private generateNaturalLanguageSpec(intent: ResolvedIntent, level: string): string {
    const specBuilder = new SpecificationBuilder(intent, level);
    
    // 1. System Overview and Context
    specBuilder.addSection('System Overview', [
      `System Name: ${this.generateSystemName(intent)}`,
      `Domain: ${intent.domain || 'General Application'}`,
      `Business Purpose: ${intent.description}`,
      `Target Users: ${this.identifyTargetUsers(intent)}`,
      `System Scope: ${this.defineSystemScope(intent)}`
    ]);

    // 2. Resolved Requirements Analysis
    specBuilder.addSection('Requirements Analysis', [
      `Primary Intent: ${intent.description}`,
      '',
      'Resolved Ambiguities:',
      ...intent.clarifications.map(c => `  • ${c}`),
      '',
      'Quality Attributes:',
      ...this.extractQualityAttributes(intent)
    ]);

    // 3. Functional Requirements
    const functionalReqs = this.generateFunctionalRequirements(intent, level);
    specBuilder.addSection('Functional Requirements', functionalReqs);

    // 4. Non-Functional Requirements  
    const nfRequirements = this.generateNonFunctionalRequirements(intent, level);
    specBuilder.addSection('Non-Functional Requirements', nfRequirements);

    // 5. System Architecture Constraints
    const archConstraints = this.generateArchitecturalConstraints(intent);
    if (archConstraints.length > 0) {
      specBuilder.addSection('Architectural Constraints', archConstraints);
    }

    // 6. Integration Requirements
    const integrationReqs = this.generateIntegrationRequirements(intent);
    if (integrationReqs.length > 0) {
      specBuilder.addSection('Integration Requirements', integrationReqs);
    }

    // 7. Security and Compliance
    if (this.requiresSecuritySection(intent)) {
      const securityReqs = this.generateSecurityRequirements(intent, level);
      specBuilder.addSection('Security Requirements', securityReqs);
    }

    // 8. Data Requirements
    const dataReqs = this.generateDataRequirements(intent);
    if (dataReqs.length > 0) {
      specBuilder.addSection('Data Requirements', dataReqs);
    }

    return specBuilder.build();
  }


  private generateSystemName(intent: ResolvedIntent): string {
    const domain = intent.domain || 'system';
    const description = intent.description.toLowerCase();
    
    // Extract key nouns for system naming
    const keyWords = description.match(/\b(app|application|system|platform|service|tool|api|website|portal|dashboard)\b/g) || [];
    const mainConcepts = description.match(/\b(manage|create|track|monitor|analyze|process|handle|store|display)\b/g) || [];
    
    if (keyWords.length > 0 && mainConcepts.length > 0) {
      return `${mainConcepts[0]!.charAt(0).toUpperCase() + mainConcepts[0]!.slice(1)} ${keyWords[0]!.charAt(0).toUpperCase() + keyWords[0]!.slice(1)}`;
    }
    
    return `${domain.charAt(0).toUpperCase() + domain.slice(1)} System`;
  }

  private identifyTargetUsers(intent: ResolvedIntent): string {
    const description = intent.description.toLowerCase();
    
    const userPatterns = [
      { pattern: /\b(admin|administrator)\b/, users: 'System Administrators' },
      { pattern: /\b(user|customer|client)\b/, users: 'End Users' },
      { pattern: /\b(manager|supervisor)\b/, users: 'Management Users' },
      { pattern: /\b(developer|programmer)\b/, users: 'Developers' },
      { pattern: /\b(analyst|reporter)\b/, users: 'Business Analysts' }
    ];

    const identifiedUsers = userPatterns
      .filter(p => p.pattern.test(description))
      .map(p => p.users);

    return identifiedUsers.length > 0 ? identifiedUsers.join(', ') : 'General Users';
  }

  private defineSystemScope(intent: ResolvedIntent): string {
    const domain = intent.domain;
    const constraints = intent.constraints || [];
    
    const scopeMap: Record<string, string> = {
      'web': 'Web-based application accessible via modern browsers',
      'mobile': 'Mobile application for iOS and Android platforms', 
      'api': 'RESTful API service for integration and data access',
      'desktop': 'Desktop application for Windows, macOS, and Linux',
      'embedded': 'Embedded system with real-time constraints'
    };

    let scope = scopeMap[domain || ''] || 'Software system with unspecified platform constraints';
    
    if (constraints.length > 0) {
      scope += `. Additional constraints: ${constraints.join(', ')}`;
    }

    return scope;
  }

  private extractQualityAttributes(intent: ResolvedIntent): string[] {
    const attributes: string[] = [];
    const description = intent.description.toLowerCase();
    const clarifications = intent.clarifications.join(' ').toLowerCase();
    const fullText = `${description} ${clarifications}`;

    const qualityPatterns = [
      { pattern: /\b(fast|quick|rapid|speed|performance)\b/, attr: 'Performance: High-speed operation and response times' },
      { pattern: /\b(secure|safety|protection)\b/, attr: 'Security: Data protection and secure access control' },
      { pattern: /\b(reliable|stable|robust)\b/, attr: 'Reliability: Consistent and dependable operation' },
      { pattern: /\b(scalable|scale|growth)\b/, attr: 'Scalability: Ability to handle increased load and growth' },
      { pattern: /\b(usable|user-friendly|intuitive)\b/, attr: 'Usability: Intuitive and accessible user interface' },
      { pattern: /\b(maintainable|flexible|modular)\b/, attr: 'Maintainability: Modular and easily updatable architecture' },
      { pattern: /\b(available|uptime|24\/7)\b/, attr: 'Availability: High uptime and continuous operation' },
      { pattern: /\b(portable|cross-platform)\b/, attr: 'Portability: Cross-platform compatibility' }
    ];

    qualityPatterns.forEach(({ pattern, attr }) => {
      if (pattern.test(fullText)) {
        attributes.push(`  • ${attr}`);
      }
    });

    return attributes.length > 0 ? attributes : ['  • Standard software quality attributes apply'];
  }

  private generateFunctionalRequirements(intent: ResolvedIntent, level: string): string[] {
    const requirements: string[] = [];
    const domain = intent.domain || 'general';
    
    // Core functionality based on intent
    requirements.push(`F1. Core Functionality`);
    requirements.push(`   ${intent.description}`);
    requirements.push('');

    // Domain-specific functional patterns
    const functionalPatterns = this.getDomainFunctionalPatterns(domain);
    functionalPatterns.forEach((pattern, index) => {
      requirements.push(`F${index + 2}. ${pattern}`);
    });

    // Requirements from resolved ambiguities
    if (intent.clarifications.length > 0) {
      requirements.push('');
      requirements.push('Clarified Requirements:');
      intent.clarifications.forEach((clarification, index) => {
        requirements.push(`F${functionalPatterns.length + index + 2}. ${clarification}`);
      });
    }

    return requirements;
  }

  private generateNonFunctionalRequirements(intent: ResolvedIntent, level: string): string[] {
    const requirements: string[] = [];
    const description = intent.description.toLowerCase();
    const clarifications = intent.clarifications.join(' ').toLowerCase();
    const fullText = `${description} ${clarifications}`;

    // Performance requirements
    if (/\b(fast|quick|performance|speed|responsive)\b/.test(fullText)) {
      requirements.push('NFR1. Performance Requirements');
      requirements.push('   - Response time < 500ms for 95% of requests');
      requirements.push('   - System throughput > 1000 requests/second');
      requirements.push('   - Page load time < 3 seconds');
    }

    // Scalability requirements
    if (/\b(scalable|scale|growth|load)\b/.test(fullText)) {
      requirements.push('NFR2. Scalability Requirements');
      requirements.push('   - Support 10x current user load');
      requirements.push('   - Horizontal scaling capability');
      requirements.push('   - Auto-scaling based on demand');
    }

    // Security requirements
    if (/\b(secure|security|protect|safe)\b/.test(fullText)) {
      requirements.push('NFR3. Security Requirements');
      requirements.push('   - Data encryption at rest and in transit');
      requirements.push('   - Role-based access control');
      requirements.push('   - Audit logging and monitoring');
    }

    // Reliability requirements
    if (/\b(reliable|available|uptime)\b/.test(fullText)) {
      requirements.push('NFR4. Reliability Requirements');
      requirements.push('   - 99.9% uptime availability');
      requirements.push('   - Graceful error handling');
      requirements.push('   - Automated failure recovery');
    }

    // Usability requirements
    if (/\b(user-friendly|usable|intuitive|easy)\b/.test(fullText)) {
      requirements.push('NFR5. Usability Requirements');
      requirements.push('   - Intuitive user interface design');
      requirements.push('   - Accessibility compliance (WCAG 2.1)');
      requirements.push('   - Multi-language support if applicable');
    }

    return requirements.length > 0 ? requirements : [
      'NFR1. Standard non-functional requirements apply',
      '   - Performance, security, reliability, and usability standards'
    ];
  }

  private generateArchitecturalConstraints(intent: ResolvedIntent): string[] {
    const constraints: string[] = [];
    const domain = intent.domain?.toLowerCase();
    const description = intent.description.toLowerCase();

    // Domain-specific constraints
    if (domain === 'web') {
      constraints.push('AC1. Web Architecture Constraints');
      constraints.push('   - RESTful API design principles');
      constraints.push('   - Responsive design for mobile compatibility');
      constraints.push('   - Browser compatibility (modern browsers)');
    } else if (domain === 'mobile') {
      constraints.push('AC1. Mobile Architecture Constraints');
      constraints.push('   - Native or cross-platform framework');
      constraints.push('   - Offline capability requirements');
      constraints.push('   - Platform-specific UI guidelines');
    } else if (domain === 'api') {
      constraints.push('AC1. API Architecture Constraints');
      constraints.push('   - OpenAPI 3.0 specification compliance');
      constraints.push('   - Stateless design principles');
      constraints.push('   - Versioning strategy implementation');
    }

    // Technology constraints from description
    if (/\b(microservices)\b/.test(description)) {
      constraints.push('AC2. Microservices Architecture');
      constraints.push('   - Service independence and loose coupling');
      constraints.push('   - Container-based deployment');
    }

    if (/\b(cloud|aws|azure|gcp)\b/.test(description)) {
      constraints.push('AC3. Cloud Architecture');
      constraints.push('   - Cloud-native design patterns');
      constraints.push('   - Infrastructure as Code');
    }

    // User constraints
    if (intent.constraints && intent.constraints.length > 0) {
      constraints.push('AC4. User-Specified Constraints');
      intent.constraints.forEach((constraint, index) => {
        constraints.push(`   - ${constraint}`);
      });
    }

    return constraints;
  }

  private generateIntegrationRequirements(intent: ResolvedIntent): string[] {
    const requirements: string[] = [];
    const description = intent.description.toLowerCase();
    const domain = intent.domain?.toLowerCase();

    // API integration requirements
    if (/\b(api|integrate|connect|sync)\b/.test(description)) {
      requirements.push('IR1. API Integration Requirements');
      requirements.push('   - RESTful API endpoints for data exchange');
      requirements.push('   - Authentication and authorization for API access');
      requirements.push('   - Rate limiting and throttling mechanisms');
    }

    // Database integration
    if (/\b(database|data|storage)\b/.test(description)) {
      requirements.push('IR2. Database Integration');
      requirements.push('   - Database connection pooling');
      requirements.push('   - Transaction management');
      requirements.push('   - Data migration and backup strategies');
    }

    // Third-party services
    if (/\b(payment|email|notification|social)\b/.test(description)) {
      requirements.push('IR3. Third-Party Service Integration');
      requirements.push('   - Secure API key management');
      requirements.push('   - Fault tolerance for external service failures');
      requirements.push('   - Service monitoring and health checks');
    }

    // Domain-specific integrations
    if (domain === 'web') {
      requirements.push('IR4. Web Integration Requirements');
      requirements.push('   - CDN integration for static assets');
      requirements.push('   - Analytics and monitoring tools');
    } else if (domain === 'mobile') {
      requirements.push('IR4. Mobile Integration Requirements');
      requirements.push('   - Push notification services');
      requirements.push('   - App store deployment integration');
    }

    return requirements;
  }

  private requiresSecuritySection(intent: ResolvedIntent): boolean {
    const description = intent.description.toLowerCase();
    const clarifications = intent.clarifications.join(' ').toLowerCase();
    const fullText = `${description} ${clarifications}`;
    
    return /\b(secure|security|protect|auth|login|encrypt|private|confidential|compliance)\b/.test(fullText) ||
           intent.domain === 'api' || // APIs typically need security
           /\b(user|account|payment|personal|sensitive)\b/.test(fullText);
  }

  private generateSecurityRequirements(intent: ResolvedIntent, level: string): string[] {
    const requirements: string[] = [];
    const description = intent.description.toLowerCase();
    const domain = intent.domain?.toLowerCase();

    // Authentication requirements
    if (/\b(user|login|auth|account)\b/.test(description)) {
      requirements.push('SR1. Authentication Requirements');
      requirements.push('   - Secure user authentication (OAuth 2.0/JWT)');
      requirements.push('   - Multi-factor authentication support');
      requirements.push('   - Password policy enforcement');
    }

    // Authorization requirements
    requirements.push('SR2. Authorization Requirements');
    requirements.push('   - Role-based access control (RBAC)');
    requirements.push('   - Principle of least privilege');
    requirements.push('   - Resource-level permissions');

    // Data protection
    requirements.push('SR3. Data Protection Requirements');
    requirements.push('   - Encryption at rest and in transit (AES-256)');
    requirements.push('   - Secure key management');
    requirements.push('   - Data anonymization for sensitive information');

    // Security monitoring
    if (level === 'comprehensive') {
      requirements.push('SR4. Security Monitoring');
      requirements.push('   - Audit logging for all security events');
      requirements.push('   - Intrusion detection and prevention');
      requirements.push('   - Security incident response procedures');
    }

    // Domain-specific security
    if (domain === 'web') {
      requirements.push('SR5. Web Security Requirements');
      requirements.push('   - HTTPS enforcement');
      requirements.push('   - Content Security Policy (CSP)');
      requirements.push('   - CSRF protection');
    } else if (domain === 'api') {
      requirements.push('SR5. API Security Requirements');
      requirements.push('   - API key management and rotation');
      requirements.push('   - Rate limiting and DDoS protection');
      requirements.push('   - Input validation and sanitization');
    }

    return requirements;
  }

  private generateDataRequirements(intent: ResolvedIntent): string[] {
    const requirements: string[] = [];
    const description = intent.description.toLowerCase();
    const domain = intent.domain?.toLowerCase();

    // Check if data handling is mentioned
    const hasDataRequirements = /\b(data|database|store|save|persist|record|track|manage|collection)\b/.test(description);
    
    if (!hasDataRequirements) {
      return [];
    }

    // Core data requirements
    requirements.push('DR1. Data Storage Requirements');
    if (domain === 'web' || domain === 'api') {
      requirements.push('   - Relational database for structured data');
      requirements.push('   - Database indexing for performance');
    } else if (domain === 'mobile') {
      requirements.push('   - Local SQLite database for offline storage');
      requirements.push('   - Cloud synchronization capability');
    } else {
      requirements.push('   - Appropriate database technology for data type');
    }

    // Data consistency
    requirements.push('DR2. Data Consistency Requirements');
    requirements.push('   - ACID transaction compliance');
    requirements.push('   - Data validation and integrity constraints');
    requirements.push('   - Referential integrity enforcement');

    // Data backup and recovery
    requirements.push('DR3. Data Backup and Recovery');
    requirements.push('   - Automated daily backups');
    requirements.push('   - Point-in-time recovery capability');
    requirements.push('   - Disaster recovery procedures');

    // Data privacy and compliance
    if (/\b(user|personal|privacy|gdpr|compliance)\b/.test(description)) {
      requirements.push('DR4. Data Privacy and Compliance');
      requirements.push('   - GDPR compliance for personal data');
      requirements.push('   - Data retention and deletion policies');
      requirements.push('   - User consent management');
    }

    return requirements;
  }

  private getDomainFunctionalPatterns(domain: string): string[] {
    const patterns: Record<string, string[]> = {
      web: [
        'User Authentication and Authorization',
        'Responsive Web Interface',
        'Data Input and Validation', 
        'Search and Filter Capabilities',
        'Export and Import Functions'
      ],
      mobile: [
        'Native Mobile Interface',
        'Offline Data Synchronization',
        'Push Notifications',
        'Biometric Authentication',
        'Location-based Services'
      ],
      api: [
        'RESTful API Endpoints',
        'Request/Response Handling',
        'API Authentication and Rate Limiting',
        'Data Serialization and Validation',
        'API Documentation and Testing'
      ],
      desktop: [
        'Native Desktop Interface',
        'File System Integration',
        'Local Data Storage',
        'System Integration',
        'Offline Operation'
      ]
    };

    return patterns[domain] || [
      'User Interface and Interaction',
      'Data Processing and Storage',
      'Business Logic Implementation',
      'Integration Capabilities'
    ];
  }

  /**
   * Enhanced NL-to-ACSL Translation
   * Converts natural language specifications to ACSL (ANSI/ISO C Specification Language)
   */
  private translateToACSL(naturalSpec: string, intent: ResolvedIntent): string {
    const acslBuilder = new ACSLBuilder(intent);
    
    // 1. Generate ACSL header and global contracts
    acslBuilder.addGlobalContracts();
    
    // 2. Generate function-level specifications
    acslBuilder.addFunctionContracts(naturalSpec);
    
    // 3. Generate data structure specifications
    acslBuilder.addDataStructures();
    
    // 4. Generate behavioral contracts
    acslBuilder.addBehavioralContracts(intent);
    
    // 5. Generate verification conditions
    acslBuilder.addVerificationConditions();
    
    return acslBuilder.build();
  }


  private extractRequirements(spec: string, intent: ResolvedIntent): Requirement[] {
    // Simplified requirement extraction
    const requirements: Requirement[] = [
      {
        id: 'REQ-001',
        type: 'functional',
        description: intent.description,
        priority: 'must',
        testable: true,
        dependencies: []
      }
    ];

    // Add requirements from clarifications
    intent.clarifications.forEach((clarification, index) => {
      requirements.push({
        id: `REQ-${String(index + 2).padStart(3, '0')}`,
        type: 'functional',
        description: clarification,
        priority: 'should',
        testable: true,
        dependencies: ['REQ-001']
      });
    });

    return requirements;
  }

  private identifyConstraints(intent: ResolvedIntent, requirements: Requirement[]): any[] {
    return (intent.constraints || []).map((constraint, index) => ({
      id: `CON-${String(index + 1).padStart(3, '0')}`,
      type: 'technical',
      description: constraint,
      impact: 'medium' as const
    }));
  }

  private makeArchitectureDecisions(intent: ResolvedIntent, requirements: Requirement[]): any[] {
    const domain = intent.domain?.toLowerCase();
    
    const decisions = [
      {
        id: 'AD-001',
        title: 'Architecture Style',
        decision: domain === 'web' ? 'Three-tier web architecture' : 
                 domain === 'api' ? 'RESTful microservices' : 'Modular monolith',
        rationale: `Selected based on domain: ${domain}`,
        alternatives: ['Microservices', 'Serverless', 'Event-driven'],
        consequences: ['Scalability considerations', 'Deployment complexity', 'Development overhead']
      }
    ];

    return decisions;
  }

  private generateDomainComponents(domain: string, requirements: Requirement[], constraints: any[]): any[] {
    const baseComponents = this.getBaseComponents(requirements);
    const domainComponents = this.getDomainSpecificComponents(domain, requirements);
    const securityComponents = this.getSecurityComponents(requirements);
    const integrationComponents = this.getIntegrationComponents(requirements);
    
    return [
      ...baseComponents,
      ...domainComponents,
      ...securityComponents,
      ...integrationComponents
    ];
  }

  private getBaseComponents(requirements: Requirement[]): any[] {
    const components = [];
    
    // Always include core components
    components.push({
      name: 'Controller Layer',
      type: 'controller',
      description: 'Request handling and business logic orchestration',
      responsibilities: ['Request validation', 'Business logic coordination', 'Response formatting'],
      dependencies: [],
      interfaces: ['HTTP API', 'Service interfaces']
    });
    
    components.push({
      name: 'Service Layer',
      type: 'service',
      description: 'Core business logic and data processing',
      responsibilities: ['Business rule enforcement', 'Data validation', 'Transaction management'],
      dependencies: ['Controller Layer'],
      interfaces: ['Service API', 'Data interfaces']
    });
    
    components.push({
      name: 'Data Access Layer',
      type: 'data',
      description: 'Database operations and data persistence',
      responsibilities: ['Data queries', 'Data persistence', 'Connection management'],
      dependencies: ['Service Layer'],
      interfaces: ['Repository pattern', 'Database connections']
    });
    
    return components;
  }
  
  private getDomainSpecificComponents(domain: string, requirements: Requirement[]): any[] {
    const components = [];
    
    if (domain === 'web') {
      components.push({
        name: 'UI Components',
        type: 'ui',
        description: 'User interface components and rendering',
        responsibilities: ['Component rendering', 'State management', 'User interaction'],
        dependencies: ['Controller Layer'],
        interfaces: ['Component API', 'Event handlers']
      });
    } else if (domain === 'mobile') {
      components.push({
        name: 'Mobile UI Layer',
        type: 'ui',
        description: 'Mobile-specific user interface components',
        responsibilities: ['Touch interaction', 'Platform adaptation', 'Offline support'],
        dependencies: ['Controller Layer'],
        interfaces: ['Platform API', 'Navigation']
      });
    } else if (domain === 'api') {
      components.push({
        name: 'API Gateway',
        type: 'gateway',
        description: 'API request routing and management',
        responsibilities: ['Request routing', 'Rate limiting', 'Authentication'],
        dependencies: [],
        interfaces: ['External API', 'Internal services']
      });
    }
    
    return components;
  }
  
  private getSecurityComponents(requirements: Requirement[]): any[] {
    const hasAuth = requirements.some(r => 
      /\b(auth|login|user|account|permission|role)\b/.test(r.description.toLowerCase())
    );
    
    if (!hasAuth) return [];
    
    return [{
      name: 'Authentication Service',
      type: 'security',
      description: 'User authentication and authorization',
      responsibilities: ['User authentication', 'Token management', 'Role-based access'],
      dependencies: ['Data Access Layer'],
      interfaces: ['Auth API', 'Token validation']
    }];
  }

  private getIntegrationComponents(requirements: Requirement[]): any[] {
    const hasIntegration = requirements.some(r => 
      /\b(integrate|external|third-party|api)\b/.test(r.description.toLowerCase())
    );
    
    if (!hasIntegration) return [];
    
    return [
      {
        name: 'Integration Layer',
        type: 'integration',
        description: 'External system integration and data transformation',
        responsibilities: ['Data transformation', 'Protocol adaptation', 'Error handling'],
        interfaces: ['REST', 'SOAP', 'GraphQL']
      },
      {
        name: 'Message Queue',
        type: 'messaging',
        description: 'Asynchronous message processing',
        responsibilities: ['Message queuing', 'Retry logic', 'Dead letter handling'],
        interfaces: ['Message Broker', 'Queue API']
      }
    ];
  }

  private designSystemInterfaces(domain: string, components: any[], requirements: Requirement[]): any[] {
    const interfaces: any[] = [];
    let interfaceId = 1;
    
    // Base API interface
    interfaces.push({
      id: `INT-${String(interfaceId++).padStart(3, '0')}`,
      name: 'Primary API',
      type: 'api',
      protocol: domain === 'web' ? 'HTTP/REST' : domain === 'api' ? 'REST' : 'HTTP',
      specification: 'OpenAPI 3.0',
      authentication: this.requiresAuth(requirements) ? 'JWT/OAuth2' : 'none',
      rateLimit: this.calculateRateLimit(requirements)
    });
    
    // Add domain-specific interfaces
    if (domain === 'web') {
      interfaces.push({
        id: `INT-${String(interfaceId++).padStart(3, '0')}`,
        name: 'WebSocket Interface',
        type: 'websocket',
        protocol: 'WebSocket',
        specification: 'RFC 6455',
        purpose: 'Real-time communication'
      });
    }
    
    if (domain === 'mobile') {
      interfaces.push({
        id: `INT-${String(interfaceId++).padStart(3, '0')}`,
        name: 'Push Notification Interface',
        type: 'push',
        protocol: 'FCM/APNS',
        specification: 'Platform specific',
        purpose: 'Mobile notifications'
      });
    }
    
    // Database interface
    interfaces.push({
      id: `INT-${String(interfaceId++).padStart(3, '0')}`,
      name: 'Database Interface',
      type: 'database',
      protocol: 'SQL/NoSQL',
      specification: 'Database specific',
      purpose: 'Data persistence'
    });
    
    return interfaces;
  }
  
  private requiresAuth(requirements: Requirement[]): boolean {
    return requirements.some(r => 
      /\b(auth|login|user|account|permission|role)\b/.test(r.description.toLowerCase())
    );
  }
  
  private calculateRateLimit(requirements: Requirement[]): string {
    // Analyze requirements for rate limiting needs
    const hasHighVolume = requirements.some(r => 
      /\b(thousand|million|concurrent|high.?load)\b/.test(r.description.toLowerCase())
    );
    
    return hasHighVolume ? '1000 req/min' : '100 req/min';
  }
  
  private designDataFlow(components: any[], interfaces: any[], scalability: any): any {
    const nodes = [
      { id: 'client', type: 'external', name: 'Client Applications' },
      ...components.map(comp => ({
        id: comp.name.toLowerCase().replace(/\s+/g, '_'),
        type: 'process',
        name: comp.name
      })),
      { id: 'database', type: 'datastore', name: 'Primary Database' }
    ];
    
    const edges = [];
    
    // Create data flow edges based on component dependencies
    for (let i = 0; i < components.length - 1; i++) {
      edges.push({
        from: components[i].name.toLowerCase().replace(/\s+/g, '_'),
        to: components[i + 1].name.toLowerCase().replace(/\s+/g, '_'),
        label: 'data_flow',
        dataType: 'JSON'
      });
    }
    
    // Add client to first component edge
    if (components.length > 0) {
      edges.push({
        from: 'client',
        to: components[0].name.toLowerCase().replace(/\s+/g, '_'),
        label: 'request',
        dataType: 'HTTP'
      });
    }
    
    // Add last component to database edge
    if (components.length > 0) {
      edges.push({
        from: components[components.length - 1].name.toLowerCase().replace(/\s+/g, '_'),
        to: 'database',
        label: 'query',
        dataType: 'SQL'
      });
    }
    
    return { nodes, edges };
  }
  
  private selectTechnologyStack(domain: string, complexity: any, constraints: any[]): any {
    const baseStack = {
      languages: ['TypeScript', 'JavaScript'],
      frameworks: [] as string[],
      databases: [] as string[],
      infrastructure: [] as string[],
      tools: ['Jest', 'ESLint', 'Prettier']
    };
    
    // Select frameworks based on domain
    if (domain === 'web') {
      baseStack.frameworks = complexity === 'high' || complexity === 'very_high' 
        ? ['React', 'Node.js', 'Express'] 
        : ['Node.js', 'Express'];
    } else if (domain === 'mobile') {
      baseStack.frameworks = ['React Native'];
      baseStack.languages.push('Swift', 'Kotlin');
    } else if (domain === 'api') {
      baseStack.frameworks = ['Node.js', 'Express', 'Fastify'];
    }
    
    // Select database based on complexity and requirements
    if (complexity === 'very_high') {
      baseStack.databases = ['PostgreSQL', 'Redis', 'MongoDB'];
    } else if (complexity === 'high') {
      baseStack.databases = ['PostgreSQL', 'Redis'];
    } else {
      baseStack.databases = ['PostgreSQL'];
    }
    
    // Select infrastructure based on scalability
    baseStack.infrastructure = complexity === 'very_high' 
      ? ['Docker', 'Kubernetes', 'AWS/GCP', 'CI/CD']
      : ['Docker', 'AWS/GCP', 'CI/CD'];
    
    return baseStack;
  }

  private designSystemArchitecture(spec: Specification): SystemArchitecture {
    const domain = this.extractDomainFromSpec(spec);
    const requirements = spec.requirements;
    const constraints = spec.constraints;
    
    // Analyze system complexity and scale
    const complexityAnalysis = this.analyzeSystemComplexity(spec);
    const scalabilityNeeds = this.analyzeScalabilityNeeds(spec, []);
    
    // Select appropriate architecture style
    const architectureStyle = this.selectArchitectureStyle(domain, complexityAnalysis, scalabilityNeeds);
    
    // Generate domain-specific components
    const components = this.generateDomainComponents(domain, requirements, constraints);
    
    // Design interfaces and integration points
    const interfaces = this.designSystemInterfaces(domain, components, requirements);
    
    // Create optimized data flow
    const dataFlow = this.designDataFlow(components, interfaces, scalabilityNeeds);
    
    // Select technology stack with rationale
    const technologyStack = this.selectTechnologyStack(domain, complexityAnalysis, constraints);
    
    // Design security and performance architectures
    const securityArchitecture = this.designSecurityArchitecture(domain, requirements);
    const performanceArchitecture = this.designPerformanceArchitecture(scalabilityNeeds, components);
    
    return {
      style: architectureStyle,
      components,
      interfaces,
      dataFlow,
      technologyStack,
      securityArchitecture,
      performanceArchitecture,
      qualityAttributes: this.extractQualityAttributesFromSpec(spec),
      deploymentStrategy: this.designDeploymentStrategy(domain, scalabilityNeeds),
      monitoringStrategy: this.designMonitoringStrategy(components, performanceArchitecture)
    };
  }

  private planDevelopmentPhases(
    spec: Specification,
    architecture: SystemArchitecture,
    teamSize: number
  ): DevelopmentPhase[] {
    const complexity = this.analyzeSystemComplexity(spec);
    const riskLevel = this.assessProjectRisk(spec, architecture, teamSize);
    const parallelizationFactor = this.calculateParallelizationFactor(teamSize, architecture.components.length);
    
    // Generate base phases based on architecture components
    const basePhases = this.generateBasePhases(architecture, complexity);
    
    // Optimize phase dependencies for parallelization
    const optimizedPhases = this.optimizePhaseDependencies(basePhases, parallelizationFactor);
    
    // Adjust durations based on team size and complexity
    const adjustedPhases = this.adjustPhaseDurations(optimizedPhases, teamSize, complexity, riskLevel);
    
    // Add risk mitigation phases if needed
    const finalPhases = this.addRiskMitigationPhases(adjustedPhases, riskLevel);
    
    return finalPhases;
  }

  private designSecurityArchitecture(domain: string, requirements: Requirement[]): any {
    const hasAuth = this.requiresAuth(requirements);
    const hasApiAccess = domain === 'api' || requirements.some(r => 
      /\b(api|endpoint|integration)\b/.test(r.description.toLowerCase())
    );
    
    return {
      authentication: hasAuth ? {
        method: 'JWT + OAuth2',
        tokenExpiry: '15m',
        refreshToken: '7d',
        mfa: 'optional'
      } : null,
      authorization: hasAuth ? {
        model: 'RBAC',
        permissions: ['read', 'write', 'admin'],
        roles: ['user', 'moderator', 'admin']
      } : null,
      dataProtection: {
        encryption: 'AES-256',
        encryptionAtRest: true,
        encryptionInTransit: true,
        keyManagement: 'AWS KMS'
      },
      apiSecurity: hasApiAccess ? {
        rateLimiting: true,
        cors: 'configured',
        inputValidation: 'strict',
        outputSanitization: true
      } : null,
      monitoring: {
        auditLogs: true,
        securityEvents: true,
        alerting: 'enabled'
      }
    };
  }

  private designPerformanceArchitecture(scalability: any, components: any[]): any {
    return {
      caching: {
        levels: scalability.level === 'enterprise' ? ['browser', 'cdn', 'application', 'database'] 
                : scalability.level === 'large' ? ['application', 'database']
                : ['application'],
        strategy: 'write-through',
        ttl: '1h'
      },
      loadBalancing: scalability.level !== 'small' ? {
        algorithm: 'round-robin',
        healthChecks: true,
        failover: 'automatic'
      } : null,
      database: {
        connectionPooling: true,
        indexing: 'optimized',
        replication: scalability.level === 'enterprise' ? 'master-slave' : null
      },
      monitoring: {
        responseTime: true,
        throughput: true,
        errorRate: true,
        resourceUsage: true
      }
    };
  }

  private extractQualityAttributesFromSpec(spec: Specification): string[] {
    const attributes: string[] = [];
    
    for (const req of spec.requirements) {
      const desc = req.description.toLowerCase();
      if (/\b(fast|performance|speed)\b/.test(desc)) attributes.push('Performance');
      if (/\b(secure|security|protect)\b/.test(desc)) attributes.push('Security');
      if (/\b(reliable|available|uptime)\b/.test(desc)) attributes.push('Reliability');
      if (/\b(scalable|scale|growth)\b/.test(desc)) attributes.push('Scalability');
      if (/\b(usable|user.?friendly|intuitive)\b/.test(desc)) attributes.push('Usability');
      if (/\b(maintainable|modular|flexible)\b/.test(desc)) attributes.push('Maintainability');
    }
    
    return [...new Set(attributes)];
  }

  private designDeploymentStrategy(domain: string, scalability: any): any {
    return {
      strategy: scalability.level === 'enterprise' ? 'blue-green' 
               : scalability.level === 'large' ? 'rolling'
               : 'simple',
      containerization: 'Docker',
      orchestration: scalability.level === 'enterprise' ? 'Kubernetes' : 'Docker Compose',
      cicd: {
        pipeline: 'GitHub Actions',
        stages: ['test', 'build', 'deploy'],
        environments: ['dev', 'staging', 'prod']
      },
      monitoring: {
        healthChecks: true,
        metricsCollection: true,
        logAggregation: true
      }
    };
  }

  private designMonitoringStrategy(components: any[], performance: any): any {
    return {
      applicationMonitoring: {
        metrics: ['response_time', 'throughput', 'error_rate'],
        alerts: ['high_latency', 'error_spike', 'resource_exhaustion'],
        dashboards: components.map(c => c.name)
      },
      infrastructureMonitoring: {
        metrics: ['cpu', 'memory', 'disk', 'network'],
        alerts: ['resource_threshold', 'service_down'],
        tools: ['Prometheus', 'Grafana']
      },
      logging: {
        levels: ['error', 'warn', 'info', 'debug'],
        aggregation: 'centralized',
        retention: '30d'
      },
      tracing: performance.caching ? {
        distributed: true,
        sampling: '10%',
        tool: 'Jaeger'
      } : null
    };
  }

  private assessProjectRisk(spec: Specification, architecture: SystemArchitecture, teamSize: number): 'low' | 'medium' | 'high' {
    let riskScore = 0;
    
    // Team size risk
    if (teamSize < 3) riskScore += 10;
    if (teamSize > 8) riskScore += 5;
    
    // Complexity risk
    const complexity = this.analyzeSystemComplexity(spec);
    if (complexity === 'very_high') riskScore += 20;
    else if (complexity === 'high') riskScore += 15;
    else if (complexity === 'medium') riskScore += 8;
    
    // Architecture risk
    if (architecture.style === 'microservices') riskScore += 15;
    if (architecture.components.length > 10) riskScore += 10;
    
    // Requirements risk
    const ambiguousReqs = spec.requirements.filter(r => 
      r.description.length < 20 || /\b(maybe|probably|should|could)\b/.test(r.description.toLowerCase())
    );
    riskScore += ambiguousReqs.length * 3;
    
    if (riskScore <= 15) return 'low';
    if (riskScore <= 35) return 'medium';
    return 'high';
  }

  private calculateParallelizationFactor(teamSize: number, componentCount: number): number {
    // Calculate how much work can be done in parallel
    const maxParallelTasks = Math.min(teamSize, componentCount);
    return Math.max(1, Math.floor(maxParallelTasks * 0.8)); // 80% efficiency factor
  }

  private generateBasePhases(architecture: SystemArchitecture, complexity: any): DevelopmentPhase[] {
    const phases: DevelopmentPhase[] = [];
    
    // Foundation phase
    phases.push({
      id: 'PHASE-001',
      name: 'Foundation & Setup',
      description: 'Project setup, infrastructure, and development environment',
      deliverables: [
        'Project structure and configuration',
        'Development environment setup',
        'CI/CD pipeline configuration',
        'Database schema design'
      ],
      duration: complexity === 'very_high' ? 8 : complexity === 'high' ? 6 : 4,
      dependencies: [],
      parallelizable: false
    });
    
    // Core development phases based on architecture components
    const componentGroups = this.groupComponentsByLayer(architecture.components);
    
    componentGroups.forEach((group, index) => {
      phases.push({
        id: `PHASE-${String(index + 2).padStart(3, '0')}`,
        name: `${group.name} Development`,
        description: `Implement ${group.name.toLowerCase()} components and functionality`,
        deliverables: group.components.map((c: any) => c.name),
        duration: this.calculatePhaseDuration(group.components, complexity),
        dependencies: index === 0 ? ['PHASE-001'] : [`PHASE-${String(index + 1).padStart(3, '0')}`],
        parallelizable: group.parallelizable
      });
    });
    
    // Integration & testing phase
    phases.push({
      id: `PHASE-${String(componentGroups.length + 2).padStart(3, '0')}`,
      name: 'Integration & Testing',
      description: 'System integration, testing, and deployment preparation',
      deliverables: [
        'Integration testing',
        'Performance testing',
        'Security testing',
        'Deployment configuration'
      ],
      duration: complexity === 'very_high' ? 10 : complexity === 'high' ? 8 : 6,
      dependencies: [`PHASE-${String(componentGroups.length + 1).padStart(3, '0')}`],
      parallelizable: false
    });
    
    return phases;
  }

  private groupComponentsByLayer(components: any[]): any[] {
    const groups = [
      {
        name: 'Data Layer',
        components: components.filter(c => c.type === 'data' || c.type === 'database'),
        parallelizable: false
      },
      {
        name: 'Service Layer',
        components: components.filter(c => c.type === 'service' || c.type === 'controller'),
        parallelizable: true
      },
      {
        name: 'Presentation Layer',
        components: components.filter(c => c.type === 'ui' || c.type === 'client'),
        parallelizable: true
      },
      {
        name: 'Integration Layer',
        components: components.filter(c => c.type === 'integration' || c.type === 'messaging'),
        parallelizable: true
      }
    ];
    
    return groups.filter(g => g.components.length > 0);
  }

  private calculatePhaseDuration(components: any[], complexity: any): number {
    const baseTimePerComponent = complexity === 'very_high' ? 8 : complexity === 'high' ? 6 : 4;
    return Math.max(3, components.length * baseTimePerComponent);
  }

  private optimizePhaseDependencies(phases: DevelopmentPhase[], parallelizationFactor: number): DevelopmentPhase[] {
    // Identify phases that can be run in parallel
    const optimizedPhases = [...phases];
    
    for (let i = 1; i < optimizedPhases.length - 1; i++) {
      const currentPhase = optimizedPhases[i];
      const nextPhase = optimizedPhases[i + 1];
      
      // If both phases are parallelizable and we have capacity
      if (currentPhase?.parallelizable && nextPhase?.parallelizable && parallelizationFactor > 1) {
        // Remove dependency between these phases to allow parallel execution
        const nextPhaseIndex = i + 1;
        if (nextPhaseIndex < optimizedPhases.length && currentPhase) {
          optimizedPhases[nextPhaseIndex] = {
            ...nextPhase,
            dependencies: currentPhase.dependencies // Same dependencies as current phase
          };
        }
      }
    }
    
    return optimizedPhases;
  }

  private adjustPhaseDurations(
    phases: DevelopmentPhase[], 
    teamSize: number, 
    complexity: any, 
    riskLevel: string
  ): DevelopmentPhase[] {
    const teamEfficiencyFactor = teamSize <= 3 ? 1.2 : teamSize <= 6 ? 1.0 : 0.9;
    const riskFactor = riskLevel === 'high' ? 1.3 : riskLevel === 'medium' ? 1.1 : 1.0;
    
    return phases.map(phase => ({
      ...phase,
      duration: Math.ceil(phase.duration * teamEfficiencyFactor * riskFactor)
    }));
  }

  private addRiskMitigationPhases(phases: DevelopmentPhase[], riskLevel: string): DevelopmentPhase[] {
    if (riskLevel !== 'high') return phases;
    
    // Add risk mitigation phases for high-risk projects
    const mitigationPhases = [...phases];
    
    // Add prototype phase after foundation
    mitigationPhases.splice(1, 0, {
      id: 'PHASE-PROTO',
      name: 'Prototype & Validation',
      description: 'Build proof-of-concept to validate architecture and reduce technical risks',
      deliverables: [
        'Technical prototype',
        'Architecture validation',
        'Risk assessment update',
        'Stakeholder feedback'
      ],
      duration: 5,
      dependencies: ['PHASE-001'],
      parallelizable: false
    });
    
    // Update subsequent phase dependencies
    for (let i = 2; i < mitigationPhases.length; i++) {
      const phase = mitigationPhases[i];
      if (phase && phase.dependencies.includes('PHASE-001')) {
        mitigationPhases[i] = {
          id: phase.id,
          name: phase.name,
          description: phase.description,
          deliverables: phase.deliverables,
          duration: phase.duration,
          parallelizable: phase.parallelizable,
          dependencies: ['PHASE-PROTO']
        };
      }
    }
    
    return mitigationPhases;
  }

  private createTimeline(phases: DevelopmentPhase[], horizonDays: number): Timeline {
    const startDate = new Date();
    const endDate = new Date(startDate);
    endDate.setDate(startDate.getDate() + horizonDays);

    return {
      startDate,
      endDate,
      milestones: phases.map((phase, index) => ({
        id: `MILE-${String(index + 1).padStart(3, '0')}`,
        name: `${phase.name} Complete`,
        date: new Date(startDate.getTime() + (phase.duration * 24 * 60 * 60 * 1000)),
        deliverables: phase.deliverables,
        criticalityLevel: index === 0 || index === phases.length - 1 ? 'critical' as const : 'medium' as const
      })),
      criticalPath: phases.filter(p => !p.parallelizable).map(p => p.id)
    };
  }

  private identifyResourceRequirements(phases: DevelopmentPhase[], teamSize: number, architecture: SystemArchitecture): ResourceRequirement[] {
    const totalDuration = phases.reduce((sum, p) => sum + p.duration, 0);
    const resources: ResourceRequirement[] = [];
    
    // Human resources
    resources.push({
      type: 'human',
      name: 'Senior Developer',
      quantity: Math.ceil(teamSize * 0.4),
      duration: totalDuration,
      cost: Math.ceil(teamSize * 0.4) * 120000 * totalDuration / 365,
      availability: 'Full-time'
    });
    
    resources.push({
      type: 'human',
      name: 'Mid-level Developer',
      quantity: Math.ceil(teamSize * 0.4),
      duration: totalDuration,
      cost: Math.ceil(teamSize * 0.4) * 90000 * totalDuration / 365,
      availability: 'Full-time'
    });
    
    resources.push({
      type: 'human',
      name: 'Junior Developer',
      quantity: Math.ceil(teamSize * 0.2),
      duration: totalDuration,
      cost: Math.ceil(teamSize * 0.2) * 60000 * totalDuration / 365,
      availability: 'Full-time'
    });
    
    if (teamSize >= 5) {
      resources.push({
        type: 'human',
        name: 'Project Manager',
        quantity: 1,
        duration: totalDuration,
        cost: 100000 * totalDuration / 365,
        availability: 'Full-time'
      });
    }
    
    // Software resources based on architecture
    resources.push({
      type: 'software',
      name: 'Development IDE & Tools',
      quantity: teamSize,
      duration: totalDuration,
      cost: teamSize * 200 * (totalDuration / 30),
      availability: 'Monthly subscription'
    });
    
    if (architecture.technologyStack.databases.includes('PostgreSQL')) {
      resources.push({
        type: 'service',
        name: 'Database Hosting',
        quantity: 1,
        duration: totalDuration,
        cost: 50 * (totalDuration / 30),
        availability: 'Cloud service'
      });
    }
    
    if (architecture.style === 'microservices') {
      resources.push({
        type: 'service',
        name: 'Container Orchestration',
        quantity: 1,
        duration: totalDuration,
        cost: 100 * (totalDuration / 30),
        availability: 'Cloud service'
      });
    }
    
    // Hardware resources for complex systems
    if (architecture.components.length > 5) {
      resources.push({
        type: 'hardware',
        name: 'Development Servers',
        quantity: Math.ceil(teamSize / 3),
        duration: totalDuration,
        cost: Math.ceil(teamSize / 3) * 2000,
        availability: 'One-time purchase'
      });
    }
    
    return resources;
  }

  private assessRisks(
    spec: Specification,
    architecture: SystemArchitecture,
    phases: DevelopmentPhase[],
    tolerance: string
  ): RiskAssessment[] {
    const risks: RiskAssessment[] = [];
    
    // Technical complexity risk
    const complexity = this.analyzeSystemComplexity(spec);
    if (complexity === 'very_high' || complexity === 'high') {
      risks.push({
        id: 'RISK-001',
        description: 'High technical complexity may lead to implementation challenges',
        probability: complexity === 'very_high' ? 0.8 : 0.6,
        impact: 0.7,
        mitigation: 'Implement prototype early, use experienced developers, conduct regular architecture reviews',
        contingency: 'Scale back features, extend timeline, add senior technical resources',
        owner: 'Technical Lead'
      });
    }
    
    // Architecture risk
    if (architecture.style === 'microservices') {
      risks.push({
        id: 'RISK-002',
        description: 'Microservices architecture complexity may cause integration issues',
        probability: 0.5,
        impact: 0.8,
        mitigation: 'Implement service mesh, establish clear API contracts, use circuit breakers',
        contingency: 'Fallback to modular monolith, simplify service boundaries',
        owner: 'Solution Architect'
      });
    }
    
    // Team size and coordination risk
    if (phases.some(p => p.parallelizable)) {
      const parallelPhases = phases.filter(p => p.parallelizable).length;
      if (parallelPhases > 3) {
        risks.push({
          id: 'RISK-003',
          description: 'Multiple parallel development streams may cause coordination issues',
          probability: 0.4,
          impact: 0.6,
          mitigation: 'Daily standups, clear interfaces, continuous integration',
          contingency: 'Reduce parallelization, increase communication overhead',
          owner: 'Project Manager'
        });
      }
    }
    
    // Requirements clarity risk
    const ambiguousReqs = spec.requirements.filter(r => 
      r.description.length < 30 || /\b(maybe|probably|should|could|might)\b/.test(r.description.toLowerCase())
    );
    if (ambiguousReqs.length > spec.requirements.length * 0.2) {
      risks.push({
        id: 'RISK-004',
        description: 'Unclear requirements may lead to rework and scope creep',
        probability: 0.7,
        impact: 0.5,
        mitigation: 'Requirements workshops, prototyping, regular stakeholder reviews',
        contingency: 'Implement change control process, extend analysis phase',
        owner: 'Business Analyst'
      });
    }
    
    // Technology stack risk
    const hasNewTech = architecture.technologyStack.frameworks.some(fw => 
      ['React Native', 'Kubernetes', 'MongoDB'].includes(fw)
    );
    if (hasNewTech) {
      risks.push({
        id: 'RISK-005',
        description: 'New or complex technologies may have learning curve impacts',
        probability: 0.6,
        impact: 0.4,
        mitigation: 'Training programs, proof of concepts, expert consultation',
        contingency: 'Switch to familiar technologies, extend development timeline',
        owner: 'Technical Lead'
      });
    }
    
    // Security and compliance risk
    const hasSecurityReqs = spec.requirements.some(r => 
      /\b(security|auth|encrypt|compliance|privacy)\b/.test(r.description.toLowerCase())
    );
    if (hasSecurityReqs) {
      risks.push({
        id: 'RISK-006',
        description: 'Security and compliance requirements may cause delays',
        probability: 0.5,
        impact: 0.7,
        mitigation: 'Security reviews, compliance audits, penetration testing',
        contingency: 'Engage security consultants, extend testing phase',
        owner: 'Security Architect'
      });
    }
    
    // Timeline risk based on phases
    const totalDuration = phases.reduce((sum, p) => sum + p.duration, 0);
    if (totalDuration > 180) { // More than 6 months
      risks.push({
        id: 'RISK-007',
        description: 'Long project duration increases risk of scope changes and resource turnover',
        probability: 0.6,
        impact: 0.6,
        mitigation: 'Incremental delivery, regular milestone reviews, team stability measures',
        contingency: 'Break into smaller releases, adjust scope',
        owner: 'Project Manager'
      });
    }
    
    return risks;
  }

  private buildDependencyGraph(phases: DevelopmentPhase[], risks: RiskAssessment[]): any {
    return {
      nodes: phases.map(p => ({
        id: p.id,
        name: p.name,
        type: 'task' as const,
        duration: p.duration
      })),
      edges: phases.flatMap(p => 
        p.dependencies.map(dep => ({
          from: dep,
          to: p.id,
          type: 'finish-to-start' as const,
          lag: 0
        }))
      ),
      criticalPath: phases.filter(p => !p.parallelizable).map(p => p.id)
    };
  }


  // Step 3a: SMART Task Generation - restored implementation
  private generatePhaseTasksSMART(
    phase: DevelopmentPhase,
    architecture: SystemArchitecture,
    granularity: 'fine' | 'medium' | 'coarse',
    maxTasks: number
  ): Task[] {
    const tasks: Task[] = [];
    const baseTaskCount = granularity === 'fine' ? 8 : granularity === 'medium' ? 5 : 3;
    const taskCount = Math.min(baseTaskCount, maxTasks);

    for (let i = 0; i < taskCount; i++) {
      const task: Task = {
        id: `${phase.id}-TASK-${String(i + 1).padStart(3, '0')}`,
        name: this.generateTaskTitle(phase, i, architecture),
        description: this.generateTaskDescription(phase, i, granularity),
        type: this.determineTaskType(phase.name, i),
        priority: this.calculateTaskPriority(phase, i, taskCount),
        estimatedHours: this.estimateTaskHours(phase, granularity),
        dependencies: this.identifyTaskDependencies(phase, i, tasks),
        acceptance: this.generateAcceptanceCriteria(phase, i, granularity),
        testable: true,
        parallelizable: this.isTaskParallelizable(phase.name, i),
        assignee: '',
        status: 'pending' as const
      };

      tasks.push(task);
    }

    return tasks;
  }

  private generateTestTasks(phase: DevelopmentPhase, phaseTasks: Task[]): Task[] {
    return phaseTasks.map((task, index) => ({
      id: `${phase.id}-TEST-${String(index + 1).padStart(3, '0')}`,
      name: `Test ${task.name}`,
      description: `Create and execute tests for ${task.name}`,
      type: 'testing' as const,
      priority: 'high' as const,
      estimatedHours: Math.ceil(task.estimatedHours * 0.5),
      dependencies: [task.id],
      status: 'pending' as const,
      acceptance: [
        {
          id: `${phase.id}-TEST-AC-${String(index + 1).padStart(3, '0')}`,
          description: `Test coverage > 80% for ${task.name}`,
          type: 'technical' as const,
          testMethod: 'Code coverage analysis',
          priority: 'must' as const
        }
      ],
      testable: true,
      parallelizable: true,
      assignee: ''
    }));
  }

  private enhanceTaskQuality(tasks: Task[], prioritizeParallelization: boolean): Task[] {
    return tasks.map(task => ({
      ...task,
      description: this.enhanceTaskDescription(task.description),
      acceptance: task.acceptance.map(ac => ({
        ...ac,
        description: this.enhanceAcceptanceCriteria([ac.description])[0] || ac.description
      })),
      estimatedHours: this.adjustTimeEstimate(task.estimatedHours, task.type)
    }));
  }

  private makeTaskDescriptionSpecific(description: string): string {
    if (description.length < 50) {
      return `${description} - Ensure implementation follows coding standards, includes error handling, and passes all quality gates`;
    }
    return description;
  }

  private makeCriteriaMeasurable(criteria: string): string {
    const measurablePatterns = [
      { pattern: /meets requirements/i, replacement: 'passes 100% of acceptance tests' },
      { pattern: /works correctly/i, replacement: 'functions without errors in all test scenarios' },
      { pattern: /is complete/i, replacement: 'delivers all specified features with 95% test coverage' }
    ];
    
    let result = criteria;
    measurablePatterns.forEach(({ pattern, replacement }) => {
      result = result.replace(pattern, replacement);
    });
    
    return result;
  }


  private calculateOverallQuality(
    intent: ResolvedIntent,
    spec: Specification,
    plan: ImplementationPlan,
    tasks: Task[],
    validationHistory: ValidationResult[]
  ): number {
    // Calculate quality metrics across multiple dimensions
    const intentClarity = this.calculateIntentClarityScore(intent);
    const specCompleteness = this.calculateSpecCompletenessScore(spec);
    const planFeasibility = this.calculatePlanFeasibilityScore(plan);
    const taskQuality = this.calculateTaskQualityScore(tasks);
    const validationConsistency = this.calculateValidationConsistencyScore(validationHistory);
    
    // Weighted average
    return (
      intentClarity * 0.2 +
      specCompleteness * 0.25 +
      planFeasibility * 0.25 +
      taskQuality * 0.2 +
      validationConsistency * 0.1
    );
  }

  private calculateIntentClarityScore(intent: ResolvedIntent): number {
    const ambiguityCount = intent.ambiguities?.length || 0;
    const clarificationCount = intent.clarifications?.length || 0;
    const confidence = intent.confidence || 0;
    
    // Score based on resolution quality
    const ambiguityScore = Math.max(0, 1 - (ambiguityCount * 0.1));
    const clarificationScore = Math.min(1, clarificationCount * 0.1);
    
    return (ambiguityScore + clarificationScore + confidence) / 3;
  }

  private calculateSpecCompletenessScore(spec: Specification): number {
    const requirementCount = spec.requirements.length;
    const constraintCount = spec.constraints.length;
    const hasNaturalLanguage = spec.naturalLanguage.length > 100;
    const hasFormalSpec = (spec as any).formalSpecification?.length > 50 || false;
    
    let score = 0;
    score += Math.min(1, requirementCount / 10) * 0.3; // Requirements completeness
    score += Math.min(1, constraintCount / 5) * 0.2; // Constraints coverage
    score += hasNaturalLanguage ? 0.25 : 0; // Natural language spec
    score += hasFormalSpec ? 0.25 : 0; // Formal specification
    
    return score;
  }

  private calculatePlanFeasibilityScore(plan: ImplementationPlan): number {
    const phaseCount = plan.phases.length;
    const resourceCount = plan.resources.length;
    const riskCount = plan.risks.length;
    const timelineRealistic = (plan.timeline as any).phases?.every((p: any) => p.duration > 0) || false;
    
    let score = 0;
    score += Math.min(1, phaseCount / 6) * 0.25; // Phase decomposition
    score += Math.min(1, resourceCount / 8) * 0.25; // Resource planning
    score += Math.min(1, riskCount / 5) * 0.25; // Risk assessment
    score += timelineRealistic ? 0.25 : 0; // Timeline feasibility
    
    return score;
  }

  private calculateTaskQualityScore(tasks: Task[]): number {
    if (tasks.length === 0) return 0;
    
    const avgAcceptanceCriteria = tasks.reduce((sum, task) => {
      if (task.acceptance.length === 0) {
        return sum;
      }
      return sum + task.acceptance.length;
    }, 0) / tasks.length;
    const testableTasksRatio = tasks.filter(t => t.testable).length / tasks.length;
    const specificTasksRatio = tasks.filter(t => t.description.length > 50).length / tasks.length;
    const parallelizableRatio = tasks.filter(t => t.parallelizable).length / tasks.length;
    
    return (
      Math.min(1, avgAcceptanceCriteria / 3) * 0.3 +
      testableTasksRatio * 0.3 +
      specificTasksRatio * 0.2 +
      parallelizableRatio * 0.2
    );
  }

  private calculateValidationConsistencyScore(validationHistory: ValidationResult[]): number {
    if (validationHistory.length === 0) return 1;
    
    const validResults = validationHistory.filter(v => v.isValid).length;
    const consistencyScore = validResults / validationHistory.length;
    
    // Calculate phase-specific consistency using stepType as phase identifier
    const phaseGroups = validationHistory.reduce((groups, v) => {
      const phase = (v as any).phase || (v as any).stepType || 'unknown';
      if (!groups[phase]) {
        groups[phase] = [];
      }
      groups[phase]!.push(v);
      return groups;
    }, {} as Record<string, ValidationResult[]>);
    
    const phaseConsistency = Object.values(phaseGroups).map(phaseResults => {
      const phaseValid = phaseResults.filter(r => r.isValid).length;
      return phaseValid / phaseResults.length;
    });
    
    if (phaseConsistency.length === 0) {
      return consistencyScore;
    }
    
    const avgPhaseConsistency = phaseConsistency.reduce((sum, score) => sum + score, 0) / phaseConsistency.length;
    
    return (consistencyScore * 0.6 + avgPhaseConsistency * 0.4);
  }

  private extractDomainFromSpec(spec: Specification): string {
    // Extract domain information from specification
    const domain = (spec as any).technicalSpecs?.domain || (spec as any).functionalSpecs?.domain;
    
    if (domain) {
      return domain;
    }
    
    // Fallback: analyze content for domain keywords
    const content = `${spec.naturalLanguage} ${spec.requirements.map((r: any) => r.description).join(' ')}`.toLowerCase();
    
    const domainKeywords: Record<string, string[]> = {
      'web': ['web', 'website', 'http', 'browser', 'frontend', 'backend'],
      'api': ['api', 'rest', 'endpoint', 'service', 'microservice', 'graphql'],
      'mobile': ['mobile', 'app', 'ios', 'android', 'react native', 'flutter'],
      'desktop': ['desktop', 'gui', 'window', 'electron', 'wpf', 'swing'],
      'data': ['data', 'database', 'analytics', 'etl', 'pipeline', 'warehouse'],
      'ml': ['machine learning', 'ai', 'neural', 'model', 'prediction', 'classification'],
      'iot': ['iot', 'sensor', 'device', 'embedded', 'hardware', 'firmware'],
      'game': ['game', 'gaming', 'unity', 'unreal', 'graphics', 'animation'],
      'financial': ['payment', 'finance', 'banking', 'transaction', 'money', 'billing'],
      'ecommerce': ['shop', 'cart', 'product', 'order', 'checkout', 'inventory']
    };
    
    let maxScore = 0;
    let detectedDomain = 'general';
    
    Object.entries(domainKeywords).forEach(([domain, keywords]) => {
      const score = keywords.reduce((sum, keyword) => {
        const matches = (content.match(new RegExp(keyword, 'g')) || []).length;
        return sum + matches;
      }, 0);
      
      if (score > maxScore) {
        maxScore = score;
        detectedDomain = domain;
      }
    });
    
    return detectedDomain;
  }

  private analyzeSystemComplexity(spec: Specification): 'low' | 'medium' | 'high' | 'very_high' {
    let complexityScore = 0;
    
    // Requirements complexity
    complexityScore += spec.requirements.length * 0.5;
    
    // Integration requirements
    const integrationReqs = spec.requirements.filter((r: any) => 
      /\b(integrate|api|service|third[\s-]?party|external)\b/i.test(r.description)
    );
    complexityScore += integrationReqs.length * 2;
    
    // Data complexity
    const dataReqs = spec.requirements.filter((r: any) => 
      /\b(database|data|storage|persistence|query|report)\b/i.test(r.description)
    );
    complexityScore += dataReqs.length * 1.5;
    
    // Security requirements
    const securityReqs = spec.requirements.filter((r: any) => 
      /\b(security|auth|encrypt|compliance|privacy|permission)\b/i.test(r.description)
    );
    complexityScore += securityReqs.length * 2.5;
    
    // Performance requirements
    const performanceReqs = spec.requirements.filter((r: any) => 
      /\b(performance|scalability|load|concurrent|response time)\b/i.test(r.description)
    );
    complexityScore += performanceReqs.length * 2;
    
    // Constraint complexity
    complexityScore += spec.constraints.length * 1.5;
    
    // Determine complexity level
    if (complexityScore <= 10) return 'low';
    if (complexityScore <= 25) return 'medium';
    if (complexityScore <= 45) return 'high';
    return 'very_high';
  }

  private analyzeScalabilityNeeds(spec: Specification, factors: string[]): string {
    let scalabilityScore = 0;
    
    const content = `${spec.naturalLanguage} ${spec.requirements.map((r: any) => r.description).join(' ')}`.toLowerCase();
    
    // Look for scalability indicators
    const scalabilityKeywords = [
      'scalable', 'scale', 'load', 'concurrent', 'users', 'traffic',
      'distributed', 'cluster', 'horizontal', 'vertical', 'elastic'
    ];
    
    scalabilityKeywords.forEach(keyword => {
      const matches = (content.match(new RegExp(keyword, 'g')) || []).length;
      scalabilityScore += matches;
    });
    
    // Factor in external factors
    factors.forEach(factor => {
      if (factor.includes('high_traffic')) scalabilityScore += 5;
      if (factor.includes('global')) scalabilityScore += 3;
      if (factor.includes('enterprise')) scalabilityScore += 4;
    });
    
    if (scalabilityScore <= 3) return 'low';
    if (scalabilityScore <= 8) return 'medium';
    if (scalabilityScore <= 15) return 'high';
    return 'very_high';
  }

  private selectArchitectureStyle(
    domain: string,
    complexity: 'low' | 'medium' | 'high' | 'very_high',
    scalability: string
  ): string {
    // Architecture selection logic based on domain, complexity, and scalability
    if (scalability === 'very_high' || complexity === 'very_high') {
      if (domain === 'api' || domain === 'web') return 'microservices';
      return 'event-driven';
    }
    
    if (scalability === 'high' && (complexity === 'high' || complexity === 'medium')) {
      if (domain === 'web' || domain === 'api') return 'modular-monolith';
      if (domain === 'data') return 'lambda-architecture';
      return 'service-oriented';
    }
    
    if (domain === 'mobile' || domain === 'desktop') return 'mvc';
    if (domain === 'data') return 'batch-processing';
    if (domain === 'iot') return 'edge-computing';
    if (domain === 'ml') return 'pipeline-architecture';
    
    return 'layered-architecture';
  }




  // Helper methods for task generation
  private generateTaskTitle(phase: DevelopmentPhase, index: number, architecture: SystemArchitecture): string {
    const titles = {
      'planning': ['Define requirements', 'Create wireframes', 'Design database schema'],
      'development': ['Implement core logic', 'Create UI components', 'Setup data layer'],
      'testing': ['Unit testing', 'Integration testing', 'User acceptance testing'],
      'deployment': ['Setup CI/CD', 'Deploy to staging', 'Production deployment']
    };

    const phaseType = this.getPhaseType(phase.name);
    const availableTitles = titles[phaseType] || ['Generic task', 'Implementation task', 'Development task'];
    
    return availableTitles[index % availableTitles.length] || `${phase.name} Task ${index + 1}`;
  }

  private generateTaskDescription(phase: DevelopmentPhase, index: number, granularity: 'fine' | 'medium' | 'coarse'): string {
    const detail = granularity === 'fine' ? 'detailed' : granularity === 'medium' ? 'moderate' : 'high-level';
    return `${detail.charAt(0).toUpperCase() + detail.slice(1)} implementation task for ${phase.name} phase, focusing on specific deliverables and outcomes.`;
  }

  private determineTaskType(phaseName: string, index: number): 'development' | 'testing' | 'documentation' | 'review' | 'deployment' {
    if (phaseName.toLowerCase().includes('test')) return 'testing';
    if (phaseName.toLowerCase().includes('deploy')) return 'deployment';
    if (phaseName.toLowerCase().includes('doc')) return 'documentation';
    if (index === 0) return 'review';
    return 'development';
  }

  private calculateTaskPriority(phase: DevelopmentPhase, index: number, totalTasks: number): 'low' | 'medium' | 'high' {
    if (index === 0) return 'high'; // First task usually critical
    if (index < totalTasks / 2) return 'medium';
    return 'low';
  }

  private estimateTaskHours(phase: DevelopmentPhase, granularity: 'fine' | 'medium' | 'coarse'): number {
    const baseHours = granularity === 'fine' ? 8 : granularity === 'medium' ? 16 : 32;
    const complexity = (phase as any).complexity || 1;
    return Math.ceil(baseHours * complexity);
  }

  private identifyTaskDependencies(phase: DevelopmentPhase, index: number, existingTasks: Task[]): string[] {
    if (index === 0) return [];
    if (index === 1 && existingTasks.length > 0 && existingTasks[0]) return [existingTasks[0].id];
    return [];
  }

  private generateAcceptanceCriteria(phase: DevelopmentPhase, index: number, granularity: 'fine' | 'medium' | 'coarse'): AcceptanceCriteria[] {
    const criteriaCount = granularity === 'fine' ? 4 : granularity === 'medium' ? 3 : 2;
    const criteria: AcceptanceCriteria[] = [];

    for (let i = 0; i < criteriaCount; i++) {
      criteria.push({
        id: `${phase.id}-AC-${index + 1}-${i + 1}`,
        description: `Acceptance criterion ${i + 1} for ${phase.name} task ${index + 1}`,
        type: 'functional',
        testMethod: 'manual verification',
        priority: 'must'
      });
    }

    return criteria;
  }

  private generateTestAcceptanceCriteria(task: Task): string[] {
    return [
      `All functionality in "${task.name}" is covered by tests`,
      `Test coverage is at least 80%`,
      `All tests pass successfully`,
      `Performance requirements are validated`
    ];
  }

  private isTaskParallelizable(phaseName: string, index: number): boolean {
    // First tasks usually not parallelizable, later ones often are
    return index > 0 && !phaseName.toLowerCase().includes('deployment');
  }

  private getPhaseType(phaseName: string): 'planning' | 'development' | 'testing' | 'deployment' {
    const name = phaseName.toLowerCase();
    if (name.includes('plan') || name.includes('design')) return 'planning';
    if (name.includes('test')) return 'testing';
    if (name.includes('deploy')) return 'deployment';
    return 'development';
  }

  private enhanceTaskDescription(description: string): string {
    // Add SMART criteria enhancements
    if (!description.includes('measurable')) {
      description += ' Ensure measurable outcomes and clear deliverables.';
    }
    return description;
  }

  private enhanceAcceptanceCriteria(criteria: string[]): string[] {
    return criteria.map(criterion => {
      if (!criterion.includes('measurable') && !criterion.includes('testable')) {
        return `${criterion} (with measurable and testable outcomes)`;
      }
      return criterion;
    });
  }

  private adjustTimeEstimate(hours: number, taskType: string): number {
    const multipliers = {
      'implementation': 1.0,
      'design': 0.8,
      'testing': 0.6,
      'documentation': 0.4,
      'review': 0.3
    };

    return Math.ceil(hours * (multipliers[taskType as keyof typeof multipliers] || 1.0));
  }

  /**
   * Step 4a: Formal Verification Condition Generation
   * Generates formal verification conditions using ACSL-like specifications
   */
  async generateFormalVerificationConditions(
    spec: Specification, 
    tasks: Task[]
  ): Promise<{ conditions: string[]; coverage: number }> {
    const conditions: string[] = [];
    
    // Generate preconditions and postconditions for each requirement
    spec.requirements.forEach((req, index) => {
      const precondition = this.generatePrecondition(req);
      const postcondition = this.generatePostcondition(req);
      
      conditions.push(`
/*@ requires ${precondition};
    ensures ${postcondition};
    assigns \\nothing;
*/
void requirement_${index + 1}_verification() {
  // Verification logic for: ${req.description}
  /*@ assert ${this.generateInvariant(req)}; */
}`);
    });

    // Generate system-level invariants
    const systemInvariants = this.generateSystemInvariants(spec);
    conditions.push(...systemInvariants);

    // Calculate verification coverage
    const coverage = this.calculateVerificationCoverage(spec, conditions);

    return { conditions, coverage };
  }

  /**
   * Step 4b: Iterative Improvement with Convergence Detection
   */
  async iterativeImprovement(
    currentSpec: Specification,
    currentPlan: ImplementationPlan,
    currentTasks: Task[],
    maxIterations: number = 5
  ): Promise<{
    improvedSpec: Specification;
    improvedPlan: ImplementationPlan;
    improvedTasks: Task[];
    convergenceReached: boolean;
    iterations: number;
  }> {
    let spec = { ...currentSpec };
    let plan = { ...currentPlan };
    let tasks = [...currentTasks];
    let convergenceReached = false;
    let iteration = 0;

    const qualityHistory: number[] = [];

    while (iteration < maxIterations && !convergenceReached) {
      iteration++;

      // Calculate current quality metrics
      const mockResolvedIntent: ResolvedIntent = {
        description: spec.naturalLanguage || 'System specification',
        priority: 'medium',
        domain: 'general',
        confidence: 0.8,
        ambiguities: [],
        clarifications: []
      };
      const currentQuality = this.calculateOverallQuality(
        mockResolvedIntent,
        spec,
        plan,
        tasks,
        []
      );
      qualityHistory.push(currentQuality);

      // Apply improvements based on quality analysis
      const improvements = await this.identifyImprovements(spec, plan, tasks, currentQuality);
      
      if (improvements.specImprovements.length > 0) {
        spec = await this.applySpecificationImprovements(spec, improvements.specImprovements);
      }
      
      if (improvements.planImprovements.length > 0) {
        plan = await this.applyPlanImprovements(plan, improvements.planImprovements);
      }
      
      if (improvements.taskImprovements.length > 0) {
        tasks = await this.applyTaskImprovements(tasks, improvements.taskImprovements);
      }

      // Check for convergence
      convergenceReached = this.checkConvergence(qualityHistory, iteration);
    }

    return {
      improvedSpec: spec,
      improvedPlan: plan,
      improvedTasks: tasks,
      convergenceReached,
      iterations: iteration
    };
  }

  /**
   * Step 4c: Quality Metrics Calculation and Tracking
   */
  calculateComprehensiveQualityMetrics(
    spec: Specification,
    plan: ImplementationPlan,
    tasks: Task[],
    validationHistory: ValidationResult[]
  ): {
    overall: number;
    dimensions: {
      completeness: number;
      consistency: number;
      clarity: number;
      testability: number;
      maintainability: number;
      performance: number;
      security: number;
    };
    trends: {
      improving: boolean;
      stable: boolean;
      declining: boolean;
    };
  } {
    const dimensions = {
      completeness: this.calculateCompleteness(spec, plan, tasks),
      consistency: this.calculateConsistency(spec, plan, tasks),
      clarity: this.calculateClarity(spec),
      testability: this.calculateTestability(tasks),
      maintainability: this.calculateMaintainability(plan, tasks),
      performance: this.calculatePerformanceScore(spec, plan),
      security: this.calculateSecurityScore(spec, tasks)
    };

    const overall = Object.values(dimensions).reduce((sum, score) => sum + score, 0) / Object.keys(dimensions).length;

    const trends = this.calculateQualityTrends(validationHistory);

    return { overall, dimensions, trends };
  }

  /**
   * Step 5a: AI Model Performance Monitoring and Adaptation
   */
  async monitorAndAdaptPerformance(
    validationHistory: ValidationResult[],
    qualityMetrics: any
  ): Promise<{
    performanceMetrics: {
      accuracy: number;
      consistency: number;
      efficiency: number;
      adaptability: number;
    };
    adaptations: string[];
    recommendations: string[];
  }> {
    const performanceMetrics = {
      accuracy: this.calculateAccuracyFromHistory(validationHistory),
      consistency: this.calculateValidationConsistencyScore(validationHistory),
      efficiency: this.calculateEfficiencyScore(qualityMetrics),
      adaptability: this.calculateAdaptabilityScore(validationHistory)
    };

    const adaptations = await this.generateAdaptations(performanceMetrics, validationHistory);
    const recommendations = await this.generateRecommendations(performanceMetrics, qualityMetrics);

    return { performanceMetrics, adaptations, recommendations };
  }

  /**
   * Step 5b: Learning from Validation Feedback
   */
  async learnFromValidationFeedback(
    validationHistory: ValidationResult[],
    qualityTrends: any
  ): Promise<{
    patterns: string[];
    improvements: string[];
    modelUpdates: any[];
  }> {
    const patterns = this.identifyValidationPatterns(validationHistory);
    const improvements = await this.generateImprovementsFromFeedback(validationHistory, patterns);
    const modelUpdates = await this.generateModelUpdates(patterns, improvements);

    return { patterns, improvements, modelUpdates };
  }

  // Helper methods for Step 4a
  private generatePrecondition(requirement: Requirement): string {
    const type = (requirement as any).type || 'functional';
    switch (type) {
      case 'security':
        return 'authenticated(user) && authorized(user, action)';
      case 'performance':
        return 'system_load < MAX_LOAD && memory_available > MIN_MEMORY';
      default:
        return 'system_initialized && input_valid';
    }
  }

  private generatePostcondition(requirement: Requirement): string {
    const description = requirement.description.toLowerCase();
    if (description.includes('create') || description.includes('add')) {
      return 'resource_created && resource_valid';
    }
    if (description.includes('update') || description.includes('modify')) {
      return 'resource_updated && consistency_maintained';
    }
    if (description.includes('delete') || description.includes('remove')) {
      return 'resource_deleted && references_cleaned';
    }
    return 'operation_completed && state_consistent';
  }

  private generateInvariant(requirement: Requirement): string {
    const type = (requirement as any).type || 'functional';
    switch (type) {
      case 'security':
        return 'security_policy_maintained';
      case 'performance':
        return 'performance_constraints_satisfied';
      case 'data':
        return 'data_integrity_maintained';
      default:
        return 'system_invariants_preserved';
    }
  }

  private generateSystemInvariants(spec: Specification): string[] {
    return [
      '/*@ global invariant system_consistency: \\forall \\integer t; t >= 0 ==> system_state_valid(t); */',
      '/*@ global invariant data_integrity: \\forall data d; in_system(d) ==> valid_data(d); */',
      '/*@ global invariant security_invariant: \\forall user u; authenticated(u) ==> authorized_actions_only(u); */'
    ];
  }

  private calculateVerificationCoverage(spec: Specification, conditions: string[]): number {
    const totalRequirements = spec.requirements.length;
    const coveredRequirements = conditions.filter(c => c.includes('requirement_')).length;
    return totalRequirements > 0 ? coveredRequirements / totalRequirements : 0;
  }

  // Helper methods for Step 4b
  private async identifyImprovements(
    spec: Specification,
    plan: ImplementationPlan,
    tasks: Task[],
    currentQuality: number
  ): Promise<{
    specImprovements: string[];
    planImprovements: string[];
    taskImprovements: string[];
  }> {
    const improvements = {
      specImprovements: [] as string[],
      planImprovements: [] as string[],
      taskImprovements: [] as string[]
    };

    // Identify specification improvements
    if (spec.requirements.length < 5) {
      improvements.specImprovements.push('add_more_detailed_requirements');
    }
    if (spec.constraints.length === 0) {
      improvements.specImprovements.push('add_technical_constraints');
    }

    // Identify plan improvements
    if (plan.phases.length < 3) {
      improvements.planImprovements.push('add_more_development_phases');
    }
    if (plan.risks.length < 3) {
      improvements.planImprovements.push('enhance_risk_assessment');
    }

    // Identify task improvements
    const testableTasksRatio = tasks.filter(t => t.testable).length / tasks.length;
    if (testableTasksRatio < 0.8) {
      improvements.taskImprovements.push('increase_task_testability');
    }

    return improvements;
  }

  private async applySpecificationImprovements(
    spec: Specification,
    improvements: string[]
  ): Promise<Specification> {
    const improvedSpec = { ...spec };

    for (const improvement of improvements) {
      switch (improvement) {
        case 'add_more_detailed_requirements':
          improvedSpec.requirements = [
            ...improvedSpec.requirements,
            {
              id: `REQ-${String(improvedSpec.requirements.length + 1).padStart(3, '0')}`,
              description: 'Enhanced requirement based on quality analysis',
              priority: 'should' as const,
              type: 'functional' as const,
              testable: true,
              dependencies: []
            }
          ];
          break;
        case 'add_technical_constraints':
          improvedSpec.constraints = [
            ...improvedSpec.constraints,
            {
              id: `CON-${String(improvedSpec.constraints.length + 1).padStart(3, '0')}`,
              type: 'technical',
              description: 'Technical constraint added for improved quality',
              impact: 'medium'
            }
          ];
          break;
      }
    }

    return improvedSpec;
  }

  private async applyPlanImprovements(
    plan: ImplementationPlan,
    improvements: string[]
  ): Promise<ImplementationPlan> {
    const improvedPlan = { ...plan };

    for (const improvement of improvements) {
      switch (improvement) {
        case 'add_more_development_phases':
          improvedPlan.phases = [
            ...improvedPlan.phases,
            {
              id: `PHASE-${String(improvedPlan.phases.length + 1).padStart(2, '0')}`,
              name: 'Quality Assurance Phase',
              description: 'Enhanced QA phase for improved quality',
              duration: 14,
              deliverables: ['Quality report', 'Test results'],
              dependencies: improvedPlan.phases.map(p => p.id),
              parallelizable: false
            }
          ];
          break;
        case 'enhance_risk_assessment':
          improvedPlan.risks = [
            ...improvedPlan.risks,
            {
              id: `RISK-${String(improvedPlan.risks.length + 1).padStart(2, '0')}`,
              description: 'Quality-related risk identified during improvement',
              probability: 0.5,
              impact: 0.5,
              mitigation: 'Enhanced quality monitoring and validation',
              contingency: 'Implement fallback quality measures',
              owner: 'QA Team'
            }
          ];
          break;
      }
    }

    return improvedPlan;
  }

  private async applyTaskImprovements(
    tasks: Task[],
    improvements: string[]
  ): Promise<Task[]> {
    const improvedTasks = [...tasks];

    for (const improvement of improvements) {
      switch (improvement) {
        case 'increase_task_testability':
          improvedTasks.forEach((task, index) => {
            if (!task.testable) {
              improvedTasks[index] = {
                ...task,
                testable: true,
                acceptance: [
                  ...task.acceptance,
                  {
                    id: `AC-${Math.random().toString(36).substr(2, 9)}`,
                    description: 'Task enhanced for testability',
                    priority: 'should' as const,
                    type: 'functional' as const,
                    testMethod: 'automated'
                  }
                ]
              };
            }
          });
          break;
      }
    }

    return improvedTasks;
  }

  private checkConvergence(qualityHistory: number[], iteration: number): boolean {
    if (iteration < 3) return false;
    
    const recentScores = qualityHistory.slice(-3);
    const maxDifference = Math.max(...recentScores) - Math.min(...recentScores);
    
    return maxDifference < 0.01; // Convergence threshold
  }

  // Helper methods for Step 4c
  private calculateCompleteness(spec: Specification, plan: ImplementationPlan, tasks: Task[]): number {
    const reqCompleteness = Math.min(1, spec.requirements.length / 10);
    const planCompleteness = Math.min(1, plan.phases.length / 5);
    const taskCompleteness = Math.min(1, tasks.length / 20);
    
    return (reqCompleteness + planCompleteness + taskCompleteness) / 3;
  }

  private calculateConsistency(spec: Specification, plan: ImplementationPlan, tasks: Task[]): number {
    // Check consistency between requirements and tasks
    const reqTaskConsistency = this.checkRequirementTaskConsistency(spec.requirements, tasks);
    const planTaskConsistency = this.checkPlanTaskConsistency(plan.phases, tasks);
    
    return (reqTaskConsistency + planTaskConsistency) / 2;
  }

  private calculateClarity(spec: Specification): number {
    const avgDescLength = spec.requirements.reduce((sum, req) => sum + req.description.length, 0) / spec.requirements.length;
    const clarityScore = Math.min(1, avgDescLength / 100); // Assume 100 chars is good clarity baseline
    
    return clarityScore;
  }

  private calculateTestability(tasks: Task[]): number {
    if (tasks.length === 0) return 0;
    return tasks.filter(t => t.testable).length / tasks.length;
  }

  private calculateMaintainability(plan: ImplementationPlan, tasks: Task[]): number {
    const parallelizableRatio = tasks.filter(t => t.parallelizable).length / tasks.length;
    const phaseStructure = Math.min(1, plan.phases.length / 6);
    
    return (parallelizableRatio + phaseStructure) / 2;
  }

  private calculatePerformanceScore(spec: Specification, plan: ImplementationPlan): number {
    const performanceReqs = spec.requirements.filter(r => 
      r.description.toLowerCase().includes('performance') || 
      r.description.toLowerCase().includes('speed') ||
      r.description.toLowerCase().includes('latency')
    );
    
    return Math.min(1, performanceReqs.length / 3);
  }

  private calculateSecurityScore(spec: Specification, tasks: Task[]): number {
    const securityReqs = spec.requirements.filter(r => 
      r.description.toLowerCase().includes('security') || 
      r.description.toLowerCase().includes('auth') ||
      r.description.toLowerCase().includes('encrypt')
    );
    
    const securityTasks = tasks.filter(t => 
      t.description.toLowerCase().includes('security') ||
      t.description.toLowerCase().includes('auth')
    );
    
    const reqScore = Math.min(1, securityReqs.length / 2);
    const taskScore = Math.min(1, securityTasks.length / 5);
    
    return (reqScore + taskScore) / 2;
  }

  private calculateQualityTrends(validationHistory: ValidationResult[]): {
    improving: boolean;
    stable: boolean;
    declining: boolean;
  } {
    if (validationHistory.length < 3) {
      return { improving: false, stable: true, declining: false };
    }

    const recentResults = validationHistory.slice(-5);
    const validCounts = recentResults.map(r => r.isValid ? 1 : 0);
    
    let improving = true;
    let declining = true;
    
    for (let i = 1; i < validCounts.length; i++) {
      const current = validCounts[i];
      const previous = validCounts[i-1];
      if (current !== undefined && previous !== undefined) {
        if (current <= previous) improving = false;
        if (current >= previous) declining = false;
      }
    }
    
    const stable = !improving && !declining;
    
    return { improving, stable, declining };
  }

  // Helper methods for Step 5a
  private calculateAccuracyFromHistory(validationHistory: ValidationResult[]): number {
    if (validationHistory.length === 0) return 0;
    const validCount = validationHistory.filter(r => r.isValid).length;
    return validCount / validationHistory.length;
  }

  private calculateEfficiencyScore(qualityMetrics: any): number {
    // Simple efficiency calculation based on overall quality and time
    return qualityMetrics.overall || 0.5;
  }

  private calculateAdaptabilityScore(validationHistory: ValidationResult[]): number {
    // Measure how well the system adapts to feedback
    if (validationHistory.length < 5) return 0.5;
    
    const recentWindow = validationHistory.slice(-5);
    const oldWindow = validationHistory.slice(-10, -5);
    
    if (oldWindow.length === 0) return 0.5;
    
    const recentAccuracy = recentWindow.filter(r => r.isValid).length / recentWindow.length;
    const oldAccuracy = oldWindow.filter(r => r.isValid).length / oldWindow.length;
    
    return Math.max(0, Math.min(1, (recentAccuracy - oldAccuracy) + 0.5));
  }

  private async generateAdaptations(
    performanceMetrics: any,
    validationHistory: ValidationResult[]
  ): Promise<string[]> {
    const adaptations: string[] = [];
    
    if (performanceMetrics.accuracy < 0.7) {
      adaptations.push('Increase validation threshold for higher accuracy');
    }
    
    if (performanceMetrics.consistency < 0.8) {
      adaptations.push('Implement more consistent validation patterns');
    }
    
    if (performanceMetrics.efficiency < 0.6) {
      adaptations.push('Optimize processing algorithms for better efficiency');
    }
    
    return adaptations;
  }

  private async generateRecommendations(
    performanceMetrics: any,
    qualityMetrics: any
  ): Promise<string[]> {
    const recommendations: string[] = [];
    
    if (qualityMetrics.overall < 0.8) {
      recommendations.push('Focus on improving overall quality metrics');
    }
    
    if (performanceMetrics.adaptability < 0.6) {
      recommendations.push('Implement more adaptive learning mechanisms');
    }
    
    recommendations.push('Continue monitoring and iterative improvement');
    
    return recommendations;
  }

  // Helper methods for Step 5b
  private identifyValidationPatterns(validationHistory: ValidationResult[]): string[] {
    const patterns: string[] = [];
    
    // Pattern: Frequent failures in specific phases
    const phaseGroups = validationHistory.reduce((groups, v) => {
      const phase = (v as any).phase || (v as any).stepType || 'unknown';
      if (!groups[phase]) {
        groups[phase] = [];
      }
      groups[phase]!.push(v);
      return groups;
    }, {} as Record<string, ValidationResult[]>);
    
    Object.entries(phaseGroups).forEach(([phase, results]) => {
      if (results && results.length > 0) {
        const failureRate = results.filter(r => !r.isValid).length / results.length;
        if (failureRate > 0.3) {
          patterns.push(`High failure rate in ${phase} phase (${(failureRate * 100).toFixed(1)}%)`);
        }
      }
    });
    
    // Pattern: Improving or declining trends
    if (validationHistory.length >= 5) {
      const recent = validationHistory.slice(-5);
      const recentSuccessRate = recent.filter(r => r.isValid).length / recent.length;
      const older = validationHistory.slice(-10, -5);
      
      if (older.length > 0) {
        const olderSuccessRate = older.filter(r => r.isValid).length / older.length;
        if (recentSuccessRate > olderSuccessRate + 0.1) {
          patterns.push('Improving validation success trend detected');
        } else if (recentSuccessRate < olderSuccessRate - 0.1) {
          patterns.push('Declining validation success trend detected');
        }
      }
    }
    
    return patterns;
  }

  private async generateImprovementsFromFeedback(
    validationHistory: ValidationResult[],
    patterns: string[]
  ): Promise<string[]> {
    const improvements: string[] = [];
    
    patterns.forEach(pattern => {
      if (pattern.includes('High failure rate')) {
        const phase = pattern.match(/in (\w+) phase/)?.[1];
        if (phase) {
          improvements.push(`Enhance validation criteria for ${phase} phase`);
          improvements.push(`Add additional quality checks for ${phase} phase`);
        }
      }
      
      if (pattern.includes('Declining')) {
        improvements.push('Review and strengthen validation processes');
        improvements.push('Implement additional quality gates');
      }
      
      if (pattern.includes('Improving')) {
        improvements.push('Continue current improvement strategies');
        improvements.push('Document successful validation patterns');
      }
    });
    
    return improvements;
  }

  private async generateModelUpdates(patterns: string[], improvements: string[]): Promise<any[]> {
    const updates: any[] = [];
    
    improvements.forEach(improvement => {
      updates.push({
        type: 'validation_enhancement',
        description: improvement,
        priority: 'medium',
        implementation: 'Update validation rules and thresholds'
      });
    });
    
    patterns.forEach(pattern => {
      updates.push({
        type: 'pattern_learning',
        description: `Learned pattern: ${pattern}`,
        priority: 'low',
        implementation: 'Update pattern recognition algorithms'
      });
    });
    
    return updates;
  }

  // Additional helper methods
  private checkRequirementTaskConsistency(requirements: Requirement[], tasks: Task[]): number {
    if (requirements.length === 0 || tasks.length === 0) return 0;
    
    let consistentTasks = 0;
    requirements.forEach(req => {
      const firstWord = req.description.toLowerCase().split(' ')[0];
      if (firstWord) {
        const relatedTasks = tasks.filter(task => 
          task.description.toLowerCase().includes(firstWord) ||
          task.name.toLowerCase().includes(firstWord)
        );
        if (relatedTasks.length > 0) consistentTasks++;
      }
    });
    
    return consistentTasks / requirements.length;
  }

  private checkPlanTaskConsistency(phases: DevelopmentPhase[], tasks: Task[]): number {
    if (phases.length === 0 || tasks.length === 0) return 0;
    
    let consistentTasks = 0;
    phases.forEach(phase => {
      const phaseTasks = tasks.filter(task => task.id.includes(phase.id));
      if (phaseTasks.length > 0) consistentTasks++;
    });
    
    return consistentTasks / phases.length;
  }
}
